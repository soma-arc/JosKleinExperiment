!function(e){function n(e){delete installedChunks[e]}function t(e){var n=document.getElementsByTagName("head")[0],t=document.createElement("script");t.type="text/javascript",t.charset="utf-8",t.src=d.p+""+e+"."+g+".hot-update.js",n.appendChild(t)}function i(){return new Promise(function(e,n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var t=new XMLHttpRequest,i=d.p+""+g+".hot-update.json";t.open("GET",i,!0),t.timeout=1e4,t.send(null)}catch(e){return n(e)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)n(new Error("Manifest request to "+i+" timed out."));else if(404===t.status)e();else if(200!==t.status&&304!==t.status)n(new Error("Manifest request to "+i+" failed."));else{try{var r=JSON.parse(t.responseText)}catch(e){return void n(e)}e(r)}}})}function r(e){var n=A[e];if(!n)return d;var t=function(t){return n.hot.active?(A[t]?A[t].parents.indexOf(e)<0&&A[t].parents.push(e):(C=[e],p=t),n.children.indexOf(t)<0&&n.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+e),C=[]),d(t)};for(var i in d)Object.prototype.hasOwnProperty.call(d,i)&&"e"!==i&&Object.defineProperty(t,i,function(e){return{configurable:!0,enumerable:!0,get:function(){return d[e]},set:function(n){d[e]=n}}}(i));return t.e=function(e){function n(){O--,"prepare"===x&&(E[e]||l(e),0===O&&0===P&&h())}return"ready"===x&&s("prepare"),O++,d.e(e).then(n,function(e){throw n(),e})},t}function o(e){var n={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],_main:p!==e,active:!0,accept:function(e,t){if(void 0===e)n._selfAccepted=!0;else if("function"==typeof e)n._selfAccepted=e;else if("object"==typeof e)for(var i=0;i<e.length;i++)n._acceptedDependencies[e[i]]=t||function(){};else n._acceptedDependencies[e]=t||function(){}},decline:function(e){if(void 0===e)n._selfDeclined=!0;else if("object"==typeof e)for(var t=0;t<e.length;t++)n._declinedDependencies[e[t]]=!0;else n._declinedDependencies[e]=!0},dispose:function(e){n._disposeHandlers.push(e)},addDisposeHandler:function(e){n._disposeHandlers.push(e)},removeDisposeHandler:function(e){var t=n._disposeHandlers.indexOf(e);t>=0&&n._disposeHandlers.splice(t,1)},check:u,apply:f,status:function(e){if(!e)return x;w.push(e)},addStatusHandler:function(e){w.push(e)},removeStatusHandler:function(e){var n=w.indexOf(e);n>=0&&w.splice(n,1)},data:k[e]};return p=void 0,n}function s(e){x=e;for(var n=0;n<w.length;n++)w[n].call(null,e)}function a(e){return+e+""===e?+e:e}function u(e){if("idle"!==x)throw new Error("check() is only allowed in idle status");return _=e,s("check"),i().then(function(e){if(!e)return s("idle"),null;M={},E={},L=e.c,b=e.h,s("prepare");var n=new Promise(function(e,n){m={resolve:e,reject:n}});y={};return l(0),"prepare"===x&&0===O&&0===P&&h(),n})}function c(e,n){if(L[e]&&M[e]){M[e]=!1;for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(y[t]=n[t]);0==--P&&0===O&&h()}}function l(e){L[e]?(M[e]=!0,P++,t(e)):E[e]=!0}function h(){s("ready");var e=m;if(m=null,e)if(_)f(_).then(function(n){e.resolve(n)},function(n){e.reject(n)});else{var n=[];for(var t in y)Object.prototype.hasOwnProperty.call(y,t)&&n.push(a(t));e.resolve(n)}}function f(t){function i(e,n){for(var t=0;t<n.length;t++){var i=n[t];e.indexOf(i)<0&&e.push(i)}}if("ready"!==x)throw new Error("apply() is only allowed in ready status");t=t||{};var r,o,u,c,l,h={},f=[],v={},p=function(){console.warn("[HMR] unexpected require("+_.moduleId+") to disposed module")};for(var m in y)if(Object.prototype.hasOwnProperty.call(y,m)){l=a(m);var _;_=y[m]?function(e){for(var n=[e],t={},r=n.slice().map(function(e){return{chain:[e],id:e}});r.length>0;){var o=r.pop(),s=o.id,a=o.chain;if((c=A[s])&&!c.hot._selfAccepted){if(c.hot._selfDeclined)return{type:"self-declined",chain:a,moduleId:s};if(c.hot._main)return{type:"unaccepted",chain:a,moduleId:s};for(var u=0;u<c.parents.length;u++){var l=c.parents[u],h=A[l];if(h){if(h.hot._declinedDependencies[s])return{type:"declined",chain:a.concat([l]),moduleId:s,parentId:l};n.indexOf(l)>=0||(h.hot._acceptedDependencies[s]?(t[l]||(t[l]=[]),i(t[l],[s])):(delete t[l],n.push(l),r.push({chain:a.concat([l]),id:l})))}}}}return{type:"accepted",moduleId:e,outdatedModules:n,outdatedDependencies:t}}(l):{type:"disposed",moduleId:m};var I=!1,w=!1,P=!1,O="";switch(_.chain&&(O="\nUpdate propagation: "+_.chain.join(" -> ")),_.type){case"self-declined":t.onDeclined&&t.onDeclined(_),t.ignoreDeclined||(I=new Error("Aborted because of self decline: "+_.moduleId+O));break;case"declined":t.onDeclined&&t.onDeclined(_),t.ignoreDeclined||(I=new Error("Aborted because of declined dependency: "+_.moduleId+" in "+_.parentId+O));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(_),t.ignoreUnaccepted||(I=new Error("Aborted because "+l+" is not accepted"+O));break;case"accepted":t.onAccepted&&t.onAccepted(_),w=!0;break;case"disposed":t.onDisposed&&t.onDisposed(_),P=!0;break;default:throw new Error("Unexception type "+_.type)}if(I)return s("abort"),Promise.reject(I);if(w){v[l]=y[l],i(f,_.outdatedModules);for(l in _.outdatedDependencies)Object.prototype.hasOwnProperty.call(_.outdatedDependencies,l)&&(h[l]||(h[l]=[]),i(h[l],_.outdatedDependencies[l]))}P&&(i(f,[_.moduleId]),v[l]=p)}var E=[];for(o=0;o<f.length;o++)l=f[o],A[l]&&A[l].hot._selfAccepted&&E.push({module:l,errorHandler:A[l].hot._selfAccepted});s("dispose"),Object.keys(L).forEach(function(e){!1===L[e]&&n(e)});for(var M,N=f.slice();N.length>0;)if(l=N.pop(),c=A[l]){var T={},R=c.hot._disposeHandlers;for(u=0;u<R.length;u++)(r=R[u])(T);for(k[l]=T,c.hot.active=!1,delete A[l],u=0;u<c.children.length;u++){var S=A[c.children[u]];S&&((M=S.parents.indexOf(l))>=0&&S.parents.splice(M,1))}}var U,z;for(l in h)if(Object.prototype.hasOwnProperty.call(h,l)&&(c=A[l]))for(z=h[l],u=0;u<z.length;u++)U=z[u],(M=c.children.indexOf(U))>=0&&c.children.splice(M,1);s("apply"),g=b;for(l in v)Object.prototype.hasOwnProperty.call(v,l)&&(e[l]=v[l]);var F=null;for(l in h)if(Object.prototype.hasOwnProperty.call(h,l)){c=A[l],z=h[l];var B=[];for(o=0;o<z.length;o++)U=z[o],r=c.hot._acceptedDependencies[U],B.indexOf(r)>=0||B.push(r);for(o=0;o<B.length;o++){r=B[o];try{r(z)}catch(e){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:l,dependencyId:z[o],error:e}),t.ignoreErrored||F||(F=e)}}}for(o=0;o<E.length;o++){var D=E[o];l=D.module,C=[l];try{d(l)}catch(e){if("function"==typeof D.errorHandler)try{D.errorHandler(e)}catch(n){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:l,error:n,orginalError:e}),t.ignoreErrored||F||(F=n),F||(F=e)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:l,error:e}),t.ignoreErrored||F||(F=e)}}return F?(s("fail"),Promise.reject(F)):(s("idle"),new Promise(function(e){e(f)}))}function d(n){if(A[n])return A[n].exports;var t=A[n]={i:n,l:!1,exports:{},hot:o(n),parents:(I=C,C=[],I),children:[]};return e[n].call(t.exports,t,t.exports,r(n)),t.l=!0,t.exports}var v=this.webpackHotUpdate;this.webpackHotUpdate=function(e,n){c(e,n),v&&v(e,n)};var p,m,y,b,_=!0,g="571bddd101f89e025719",k={},C=[],I=[],w=[],x="idle",P=0,O=0,E={},M={},L={},A={};d.m=e,d.c=A,d.i=function(e){return e},d.d=function(e,n,t){d.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:t})},d.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return d.d(n,"a",n),n},d.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},d.p="",d.h=function(){return g},r(6)(d.s=6)}([function(e,n,t){"use strict";function i(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,n){for(var t=0;t<n.length;t++){var i=n[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(n,t,i){return t&&e(n.prototype,t),i&&e(n,i),n}}(),o=Math.sqrt(2),s=function(){function e(n,t){i(this,e),this.re=n,this.im=t}return r(e,[{key:"add",value:function(n){return new e(this.re+n.re,this.im+n.im)}},{key:"sub",value:function(n){return new e(this.re-n.re,this.im-n.im)}},{key:"mult",value:function(n){return new e(this.re*n.re-this.im*n.im,this.re*n.im+this.im*n.re)}},{key:"div",value:function(n){if(n.isInfinity())return e.ZERO;var t=n.re*n.re+n.im*n.im;return t<1e-7?new e(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY):new e((this.re*n.re+this.im*n.im)/t,(this.im*n.re-this.re*n.im)/t)}},{key:"scale",value:function(n){return new e(this.re*n,this.im*n)}},{key:"arg",value:function(){return Math.atan2(this.im,this.re)}},{key:"conjugate",value:function(){return new e(this.re,-this.im)}},{key:"normalize",value:function(){return this.scale(1/this.abs())}},{key:"abs",value:function(){return Math.sqrt(this.re*this.re+this.im*this.im)}},{key:"absSq",value:function(){return this.re*this.re+this.im*this.im}},{key:"eq",value:function(e){var n=this.re-e.re,t=this.im-e.im;return n*n+t*t<1e-7}},{key:"sq",value:function(){return new e(this.re*this.re-this.im*this.im,this.re*this.im+this.im*this.re)}},{key:"sqrt",value:function(){return this.im>0?new e(Math.sqrt(this.re+Math.sqrt(this.re*this.re+this.im*this.im))/o,Math.sqrt(-this.re+Math.sqrt(this.re*this.re+this.im*this.im))/o):this.i<0?new e(Math.sqrt(this.re+Math.sqrt(this.re*this.re+this.im*this.im))/o,-Math.sqrt(-this.re+Math.sqrt(this.re*this.re+this.im*this.im))/o):this.re<0?new e(0,Math.sqrt(Math.abs(this.re))):new e(Math.sqrt(this.re),0)}},{key:"isInfinity",value:function(){return this.re===Number.POSITIVE_INFINITY||this.im===Number.POSITIVE_INFINITY}},{key:"isZero",value:function(){return Math.abs(this.re)<1e-7&&Math.abs(this.im)<1e-7}},{key:"isReal",value:function(){return Math.abs(this.im)<1e-7}},{key:"isPureImaginary",value:function(){return Math.abs(this.re)<1e-7}},{key:"hasNaN",value:function(){return isNaN(this.re)||isNaN(this.im)}},{key:"linearArray",get:function(){return[this.re,this.im]}}],[{key:"sum",value:function(e,n){return e.add(n)}},{key:"diff",value:function(e,n){return e.sub(n)}},{key:"prod",value:function(e,n){return e.mult(n)}},{key:"quot",value:function(e,n){return e.div(n)}},{key:"conjugate",value:function(e){return e.conjugate()}},{key:"abs",value:function(e){return e.abs()}},{key:"absSq",value:function(e){return e.absSq()}},{key:"eq",value:function(e,n){var t=e.re-n.re,i=e.im-n.im;return t*t+i*i<1e-7}},{key:"distance",value:function(e,n){return e.sub(n).abs()}},{key:"sq",value:function(e){return e.sq()}},{key:"sqrt",value:function(e){return e.sqrt()}},{key:"dot",value:function(e,n){return e.re*n.re+e.im*n.im}},{key:"ZERO",get:function(){return new e(0,0)}},{key:"ONE",get:function(){return new e(1,0)}},{key:"I",get:function(){return new e(0,1)}},{key:"MINUS_ONE",get:function(){return new e(-1,0)}},{key:"INFINITY",get:function(){return new e(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}}]),e}();n.default=s},function(e,n,t){"use strict";function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function r(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0}),n.InvertedMaskitCanvas=n.MaskitCanvas=void 0;var s=function(){function e(e,n){for(var t=0;t<n.length;t++){var i=n[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(n,t,i){return t&&e(n.prototype,t),i&&e(n,i),n}}(),a=t(5),u=t(0),c=function(e){return e&&e.__esModule?e:{default:e}}(u),l=t(7),h=function(){function e(n,t,i){o(this,e),this.canvasId=n,this.maskit=t,this.fragment=i,this.canvas=document.getElementById(n),this.pixelRatio=window.devicePixelRatio,this.canvas.style.width=this.canvas.width+"px",this.canvas.style.height=this.canvas.height+"px",this.canvas.width=this.canvas.width*this.pixelRatio,this.canvas.height=this.canvas.height*this.pixelRatio,this.canvasRatio=this.canvas.width/this.canvas.height/2,this.gl=(0,a.GetWebGL2Context)(this.canvas),this.setupShader(),this.setUniformLocations(),this.translate=new c.default(0,1),this.scale=2.1,this.kleinIterations=200,this.sceneScaleFactor=1.5}return s(e,[{key:"setupShader",value:function(){this.vertexBuffer=(0,a.CreateSquareVbo)(this.gl),this.renderProgram=this.gl.createProgram(),(0,a.AttachShader)(this.gl,l,this.renderProgram,this.gl.VERTEX_SHADER),(0,a.AttachShader)(this.gl,this.fragment,this.renderProgram,this.gl.FRAGMENT_SHADER),(0,a.LinkProgram)(this.gl,this.renderProgram),this.renderVAttrib=this.gl.getAttribLocation(this.renderProgram,"a_vertex"),this.gl.enableVertexAttribArray(this.renderVAttrib)}},{key:"setUniformLocations",value:function(){this.uniLocations=[],this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_resolution")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_geometry")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_kleinIterations")),this.maskit.setUniformLocations(this.gl,this.uniLocations,this.renderProgram)}},{key:"setUniformValues",value:function(){var e=0;this.gl.uniform2f(this.uniLocations[e++],this.canvas.width,this.canvas.height),this.gl.uniform3f(this.uniLocations[e++],this.translate.re,this.translate.im,this.scale),this.gl.uniform1i(this.uniLocations[e++],this.kleinIterations),e=this.maskit.setUniformValues(this.gl,this.uniLocations,e,this.scale)}},{key:"render",value:function(){this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.useProgram(this.renderProgram),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexBuffer),this.gl.vertexAttribPointer(this.renderCanvasVAttrib,2,this.gl.FLOAT,!1,0,0),this.setUniformValues(),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.flush()}},{key:"calcCanvasCoord",value:function(e,n){var t=this.canvas.getBoundingClientRect();return new c.default(this.scale*((e-t.left)*this.pixelRatio/this.canvas.height-this.canvasRatio),this.scale*-((n-t.top)*this.pixelRatio/this.canvas.height-.5))}},{key:"calcSceneCoord",value:function(e,n){return this.calcCanvasCoord(e,n).add(this.translate)}},{key:"setupMouseListener",value:function(){this.mouseState={isPressing:!1,prevPosition:new c.default(0,0),prevTranslate:new c.default(0,0)},this.boundOnMouseWheel=this.onMouseWheel.bind(this),this.canvas.addEventListener("wheel",this.boundOnMouseWheel),this.boundOnMouseDown=this.onMouseDown.bind(this),this.canvas.addEventListener("mousedown",this.boundOnMouseDown),this.boundOnMouseMove=this.onMouseMove.bind(this),this.canvas.addEventListener("mousemove",this.boundOnMouseMove),this.boundOnMouseUp=this.onMouseUp.bind(this),this.canvas.addEventListener("mouseup",this.boundOnMouseUp),this.canvas.addEventListener("contextmenu",function(e){return e.preventDefault()})}},{key:"onMouseWheel",value:function(e){e.preventDefault(),e.deltaY>0?this.scale*=this.sceneScaleFactor:this.scale/=this.sceneScaleFactor,this.render()}},{key:"onMouseDown",value:function(e){}},{key:"onMouseMove",value:function(e){}},{key:"onMouseUp",value:function(e){this.mouseState.isPressing=!1,this.maskit.release()}}],[{key:"MOUSE_BUTTON_LEFT",get:function(){return 0}},{key:"MOUSE_BUTTON_WHEEL",get:function(){return 1}},{key:"MOUSE_BUTTON_RIGHT",get:function(){return 2}}]),e}();n.MaskitCanvas=function(e){function n(e,t,r){o(this,n);var s=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e,t,r));return s.maskit.addParameterChangedListener(function(e){s.render()}),s.setupMouseListener(),s}return r(n,e),s(n,[{key:"onMouseDown",value:function(e){e.preventDefault();var n=this.calcSceneCoord(e.clientX,e.clientY);e.button===h.MOUSE_BUTTON_LEFT&&(this.maskit.select(n),this.render()),this.mouseState.prevPosition=n,this.mouseState.prevTranslate=this.translate,this.mouseState.isPressing=!0}},{key:"onMouseMove",value:function(e){var n=this.calcSceneCoord(e.clientX,e.clientY);this.maskit.updateOrbitPoints(n),this.mouseState.isPressing&&(e.button===h.MOUSE_BUTTON_LEFT?this.maskit.move(n):e.button===h.MOUSE_BUTTON_RIGHT&&(this.translate=this.translate.sub(n.sub(this.mouseState.prevPosition)),this.render()))}}]),n}(h),n.InvertedMaskitCanvas=function(e){function n(e,t,r){o(this,n);var s=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e,t,r));return s.maskit.addParameterChangedListener(function(e){s.render()}),s.setupMouseListener(),s}return r(n,e),s(n,[{key:"onMouseDown",value:function(e){e.preventDefault();var n=this.calcSceneCoord(e.clientX,e.clientY);this.mouseState.prevPosition=n,this.mouseState.prevTranslate=this.translate,this.mouseState.isPressing=!0}},{key:"onMouseMove",value:function(e){if(this.mouseState.isPressing){var n=this.calcSceneCoord(e.clientX,e.clientY);e.button===h.MOUSE_BUTTON_RIGHT&&(this.translate=this.translate.sub(n.sub(this.mouseState.prevPosition)),this.render())}}}]),n}(h)},function(e,n,t){"use strict";function i(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,n){for(var t=0;t<n.length;t++){var i=n[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(n,t,i){return t&&e(n.prototype,t),i&&e(n,i),n}}(),o=t(0),s=function(e){return e&&e.__esModule?e:{default:e}}(o),a=function(){function e(n,t,r){i(this,e),this.t=new s.default(n,t),this.n=r,this.k=2*Math.cos(Math.PI/this.n),this.update(),this.pointRadius=.03,this.lineWidth=.01,this.circumferenceWidth=.02,this.selectedComponentId=-1,this.diffToComponent=new s.default(0,0),this.invCircleCenter=new s.default(0,1),this.invCircleR=1,this.drawLines=!1,this.drawCircle=!1,this.applyInversion=!0,this.trackOrbit=!1,this.drawInner=!1,this.parameterChangedListener=[],this.maxOrbitPoints=20,this.orbitPoints=new Array(2*this.maxOrbitPoints)}return r(e,[{key:"addParameterChangedListener",value:function(e){this.parameterChangedListener.push(e)}},{key:"onParameterChanged",value:function(){var e=!0,n=!1,t=void 0;try{for(var i,r=this.parameterChangedListener[Symbol.iterator]();!(e=(i=r.next()).done);e=!0){(0,i.value)(this)}}catch(e){n=!0,t=e}finally{try{!e&&r.return&&r.return()}finally{if(n)throw t}}}},{key:"release",value:function(){this.selectedComponentId=-1}},{key:"update",value:function(){this.symmetricalPoint=new s.default(.5*-this.t.im,.5*this.t.re),this.halfK=.5*this.k,this.rightBelowP=new s.default(this.halfK,0),this.leftBelowP=new s.default(-this.halfK,0),this.rightAbobeP=new s.default(this.halfK-this.t.im,this.t.re),this.leftAbobeP=new s.default(-this.halfK-this.t.im,this.t.re);var e=this.rightAbobeP.sub(this.rightBelowP);this.lineRightNormal=new s.default(-e.im,e.re),this.lineLeftNormal=this.lineRightNormal.scale(-1)}},{key:"updateOrbitPoints",value:function(e){this.trackOrbit&&(this.orbitPoints=this.computeOrbit(e,this.maxOrbitPoints),this.onParameterChanged())}},{key:"select",value:function(n){var t=n.sub(this.rightAbobeP);if(t.abs()<this.pointRadius)return this.selectedComponentId=e.POINT_RIGHT_ABOVE,this.diffToComponent=t,!0;var i=n.sub(this.rightBelowP);if(i.abs()<this.pointRadius)return this.selectedComponentId=e.POINT_RIGHT_BELOW,this.diffToComponent=i,!0;var r=n.sub(this.leftAbobeP);if(r.abs()<this.pointRadius)return this.selectedComponentId=e.POINT_LEFT_ABOVE,this.diffToComponent=r,!0;var o=n.sub(this.leftBelowP);if(o.abs()<this.pointRadius)return this.selectedComponentId=e.POINT_LEFT_BELOW,this.diffToComponent=o,!0;var a=n.sub(this.symmetricalPoint);if(a.abs()<this.pointRadius)return this.selectedComponentId=e.POINT_SYMMETRICAL,this.diffToComponent=a,!0;if(!this.drawCircle)return!1;var u=n.sub(this.invCircleCenter),c=u.abs(),l=this.invCircleR-c;return 0<l&&l<this.circumferenceWidth?(this.selectedComponentId=e.INVERSION_CIRCLE_CIRCUMFERENCE,this.diffToComponent=new s.default(l,l),!0):c<this.invCircleR&&(this.selectedComponentId=e.INVERSION_CIRCLE_BODY,this.diffToComponent=u,!0)}},{key:"move",value:function(n){switch(this.selectedComponentId){case e.POINT_RIGHT_ABOVE:var t=n.sub(this.diffToComponent);this.t=new s.default(t.im,this.halfK-t.re);break;case e.POINT_RIGHT_BELOW:var i=n.sub(this.diffToComponent);this.k=2*i.re;break;case e.POINT_LEFT_ABOVE:var r=n.sub(this.diffToComponent);this.t=new s.default(r.im,-this.halfK-r.re);break;case e.POINT_LEFT_BELOW:var o=n.sub(this.diffToComponent);this.k=2*o.re;break;case e.POINT_SYMMETRICAL:var a=n.sub(this.diffToComponent);this.t=new s.default(2*a.im,2*-a.re);break;case e.INVERSION_CIRCLE_BODY:this.invCircleCenter=n.sub(this.diffToComponent);break;case e.INVERSION_CIRCLE_CIRCUMFERENCE:this.invCircleR=s.default.distance(this.invCircleCenter,n)+this.diffToComponent.re;break;default:return!1}return this.update(),this.onParameterChanged(),!0}},{key:"lineY",value:function(e,n){return.5*n.re+Math.sign(.5*n.im)*(2*n.re-1.95)/4*Math.sign(e.re+.5*n.im)*(1-Math.exp(-(7.2-15*(1.95-n.re))*Math.abs(e.re+.5*n.im)))}},{key:"transA",value:function(e,n){var t=1/e.absSq(),i=e.scale(-t);return i.re=-n.im-i.re,i.im=n.re+i.im,i}},{key:"computeOrbit",value:function(e,n){for(var t=[e],i=1,r=new s.default(e.re,e.im),o=0;o<100;o++){var a=this.k/2+this.t.im*r.im/this.t.re;if((r.re<-a||a<r.re)&&(r.re+=a,r.re=Math.abs(r.re%this.k),r.re-=a,t.push(new s.default(r.re,r.im)),++i===n))break;if(r.im>=this.lineY(r,this.t)&&(r=new s.default(-this.t.im,this.t.re).sub(r),t.push(new s.default(r.re,r.im)),++i===n))break;if(r=this.transA(r,this.t),t.push(new s.default(r.re,r.im)),++i===n)break;if(r.im<0||this.t.re<r.im){for(var u=t[i-1],c=i;c<n;c++)t.push(u);break}}for(var l=new Array(2*n),h=0;h<n;h++)l[2*h+0]=t[h].re,l[2*h+1]=t[h].im;return l}},{key:"setUniformLocations",value:function(e,n,t){n.push(e.getUniformLocation(t,"u_maskit.uv")),n.push(e.getUniformLocation(t,"u_maskit.k")),n.push(e.getUniformLocation(t,"u_maskit.symmetricalPoint")),n.push(e.getUniformLocation(t,"u_maskit.lineLeftNormal")),n.push(e.getUniformLocation(t,"u_maskit.lineLeftPoints")),n.push(e.getUniformLocation(t,"u_maskit.lineRightNormal")),n.push(e.getUniformLocation(t,"u_maskit.lineRightPoints")),n.push(e.getUniformLocation(t,"u_maskit.inversionCircle")),n.push(e.getUniformLocation(t,"u_maskit.ui")),n.push(e.getUniformLocation(t,"u_maskit.drawLines")),n.push(e.getUniformLocation(t,"u_maskit.drawCircle")),n.push(e.getUniformLocation(t,"u_maskit.drawInner")),n.push(e.getUniformLocation(t,"u_maskit.applyInversion")),n.push(e.getUniformLocation(t,"u_maskit.trackOrbit")),n.push(e.getUniformLocation(t,"u_maskit.orbitPoints"))}},{key:"setUniformValues",value:function(e,n,t,i){var r=t;return e.uniform2f(n[r++],this.t.re,this.t.im),e.uniform1f(n[r++],this.k),e.uniform2f(n[r++],this.symmetricalPoint.re,this.symmetricalPoint.im),e.uniform2f(n[r++],this.lineLeftNormal.re,this.lineLeftNormal.im),e.uniform4f(n[r++],this.leftBelowP.re,this.leftBelowP.im,this.leftAbobeP.re,this.leftAbobeP.im),e.uniform2f(n[r++],this.lineRightNormal.re,this.lineRightNormal.im),e.uniform4f(n[r++],this.rightBelowP.re,this.rightBelowP.im,this.rightAbobeP.re,this.rightAbobeP.im),e.uniform4f(n[r++],this.invCircleCenter.re,this.invCircleCenter.im,this.invCircleR,this.invCircleR*this.invCircleR),e.uniform3f(n[r++],this.pointRadius,this.lineWidth,this.circumferenceWidth),e.uniform1i(n[r++],this.drawLines),e.uniform1i(n[r++],this.drawCircle),e.uniform1i(n[r++],this.drawInner),e.uniform1i(n[r++],this.applyInversion),e.uniform1i(n[r++],this.trackOrbit),e.uniform2fv(n[r++],this.orbitPoints),r}}],[{key:"POINT_RIGHT_ABOVE",get:function(){return 0}},{key:"POINT_RIGHT_BELOW",get:function(){return 1}},{key:"POINT_LEFT_ABOVE",get:function(){return 2}},{key:"POINT_LEFT_BELOW",get:function(){return 3}},{key:"POINT_SYMMETRICAL",get:function(){return 4}},{key:"INVERSION_CIRCLE_BODY",get:function(){return 5}},{key:"INVERSION_CIRCLE_CIRCUMFERENCE",get:function(){return 6}}]),e}();n.default=a},function(e,n){e.exports="#version 300 es\nprecision mediump float;\n\nconst int MAX_ORBIT_POINTS = 20;\nstruct Maskit {\n    vec2 uv;\n    float k;\n    vec2 symmetricalPoint;\n    vec2 lineLeftNormal;\n    vec4 lineLeftPoints; // [below, above]\n    vec2 lineRightNormal;\n    vec4 lineRightPoints;\n    vec4 inversionCircle;\n    vec3 ui; // [point radius, line width, circumference width]\n    bool drawLines;\n    bool drawCircle;\n    bool drawInner;\n    bool applyInversion;\n    bool trackOrbit;\n    vec2 orbitPoints[MAX_ORBIT_POINTS];\n};\n\n\nuniform vec2 u_resolution;\nuniform vec3 u_geometry; // [translateX, translateY, scale]\nuniform int u_kleinIterations;\nuniform Maskit u_maskit;\n\nconst vec3 BLACK = vec3(0, 0, 0.01);\nconst vec3 WHITE = vec3(1);\nconst vec3 RED = vec3(0.8, 0, 0);\nconst vec3 GREEN = vec3(0, 0.8, 0);\nconst vec3 BLUE = vec3(0, 0, 0.8);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 circleInvert(const vec2 pos, const vec4 circle){\n    vec2 p = pos - circle.xy;\n    float d = length(p);\n    return (p * circle.w)/(d * d) + circle.xy;\n}\n\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec2 TransA(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x; z.y = uv.x + z.y;\n    return z;\n}\n\nvec2 TransAInv(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z + vec2(uv.y,-uv.x), z + vec2(uv.y, -uv.x));\n\tz.x += uv.y; z.y = uv.x - z.y;\n\tz *= iR;\n    return z;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 computeColor(float n){\n\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n}\n\nvec3 computeColor2(float n, float numTransA) {\n    if(n == 0.) {\n        return u_maskit.drawInner ? computeColor(numTransA) : BLACK;\n    }\n    return hsv2rgb(vec3(0. + 0.05 * (n -1.), 1.0, 1.0));\n}\n\nconst int LOOP_NUM = 200;\nvec3 josKleinian(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        loopNum++;\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6)\n            return u_maskit.drawInner ?\n                hsv2rgb(vec3(0.01 * (loopNum-1.), 1., 1.)) :\n                BLACK;\n\n        if(pos.y <= 0. || uv.x < pos.y) {\n        \treturn computeColor(loopNum);\n        }\n\n        llz=lz; lz=pos;\n    }\n    return BLACK;\n}\n\nvec3 josKleinianIIS(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        numTransA++;\n        if(uv.x < pos.y) {\n            pos.y -= uv.x;\n            pos.y *= -1.;\n            pos.y += uv.x;\n            loopNum++;\n        }\n        if(pos.y <= 0.){\n            pos.y *= -1.;\n            loopNum++;\n        }\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) return computeColor2(loopNum, numTransA);\n\n        llz=lz; lz=pos;\n    }\n    return computeColor2(loopNum, numTransA);\n}\n\nbool renderUI(vec2 pos, out vec3 col){\n    col = BLACK;\n\n    if (distance(pos, u_maskit.symmetricalPoint) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    }\n\n    if(u_maskit.drawLines) {\n        // draw line3\n        if(abs(pos.y - lineY(pos, u_maskit.uv)) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw left line\n        float ldot = dot(u_maskit.lineLeftPoints.xy - pos, u_maskit.lineLeftNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw right line\n        ldot = dot(u_maskit.lineRightPoints.xy - pos, u_maskit.lineRightNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n    }\n    return false;\n}\n\n// front to back blend\nvec4 blendCol(vec4 srcC, vec4 outC){\n\tsrcC.rgb *= srcC.a;\n\treturn outC + srcC * (1.0 - outC.a);\n}\n\nfloat SAMPLE_NUM = 10.;\nout vec4 outColor;\nvoid main() {\n    vec3 sum = vec3(0);\n\tfloat ratio = u_resolution.x / u_resolution.y / 2.0;\n\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (gl_FragCoord.xy + (rand2n(gl_FragCoord.xy, i))) / u_resolution.yy ) - vec2(ratio, 0.5);\n        position *= u_geometry.z;\n        position += u_geometry.xy;\n\n        vec4 cc = vec4(0);\n        if(u_maskit.drawCircle) {\n            if(distance(position, u_maskit.inversionCircle.xy) < u_maskit.inversionCircle.z) {\n                cc = vec4(0, 0, 1., 0.5);\n            }\n        }\n\n        position = circleInvert(position, u_maskit.inversionCircle);\n        if(u_maskit.drawLines) {\n            vec3 c = BLACK;\n            bool render = renderUI(position, c);\n            if(render) {\n                sum += c;\n                continue;\n            }\n        }\n\n        if(u_maskit.applyInversion) {\n            sum += blendCol(vec4(josKleinianIIS(position,\n                                                u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        } else {\n            sum += blendCol(vec4(josKleinian(position,\n                                             u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        }\n    }\n    outColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n"},function(e,n){e.exports="#version 300 es\nprecision mediump float;\n\nconst int MAX_ORBIT_POINTS = 20;\nstruct Maskit {\n    vec2 uv;\n    float k;\n    vec2 symmetricalPoint;\n    vec2 lineLeftNormal;\n    vec4 lineLeftPoints; // [below, above]\n    vec2 lineRightNormal;\n    vec4 lineRightPoints;\n    vec4 inversionCircle;\n    vec3 ui; // [point radius, line width, circumference width]\n    bool drawLines;\n    bool drawCircle;\n    bool drawInner;\n    bool applyInversion;\n    bool trackOrbit;\n    vec2 orbitPoints[MAX_ORBIT_POINTS];\n};\n\nuniform vec2 u_resolution;\nuniform vec3 u_geometry; // [translateX, translateY, scale]\nuniform int u_kleinIterations;\nuniform Maskit u_maskit;\n\nconst vec3 BLACK = vec3(0, 0, 0.0);\nconst vec3 WHITE = vec3(1);\nconst vec3 RED = vec3(0.8, 0, 0);\nconst vec3 GREEN = vec3(0, 0.8, 0);\nconst vec3 BLUE = vec3(0, 0, 0.8);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 circleInvert(const vec2 pos, const vec4 circle){\n    vec2 p = pos - circle.xy;\n    float d = length(p);\n    return (p * circle.w)/(d * d) + circle.xy;\n}\n\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec2 TransA(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x; z.y = uv.x + z.y;\n    return z;\n}\n\nvec2 TransAInv(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z + vec2(uv.y,-uv.x), z + vec2(uv.y, -uv.x));\n\tz.x += uv.y; z.y = uv.x - z.y;\n\tz *= iR;\n    return z;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 computeColor(float n){\n\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n}\n\nvec3 computeColor2(float n, float numTransA) {\n    if(n == 0.) {\n        return u_maskit.drawInner ? computeColor(numTransA) : BLACK;\n    }\n    return hsv2rgb(vec3(0. + 0.05 * (n -1.), 1.0, 1.0));\n}\n\nconst int LOOP_NUM = 200;\nvec3 josKleinian(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        loopNum++;\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6)\n            return u_maskit.drawInner ?\n                hsv2rgb(vec3(0.01 * (loopNum-1.), 1., 1.)) :\n                BLACK;\n\n        if(pos.y <= 0. || uv.x < pos.y) {\n        \treturn computeColor(loopNum);\n        }\n\n        llz=lz; lz=pos;\n    }\n    return BLACK;\n}\n\nvec3 josKleinianIIS(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        numTransA++;\n        if(uv.x < pos.y) {\n            pos.y -= uv.x;\n            pos.y *= -1.;\n            pos.y += uv.x;\n            loopNum++;\n        }\n        if(pos.y <= 0.){\n            pos.y *= -1.;\n            loopNum++;\n        }\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) return computeColor2(loopNum, numTransA);\n\n        llz=lz; lz=pos;\n    }\n    return computeColor2(loopNum, numTransA);\n}\n\nbool renderUI(vec2 pos, out vec3 col){\n    col = BLACK;\n\n    if (distance(pos, u_maskit.symmetricalPoint) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    }\n\n    if(u_maskit.drawLines) {\n        // draw line3\n        if(abs(pos.y - lineY(pos, u_maskit.uv)) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw left line\n        float ldot = dot(u_maskit.lineLeftPoints.xy - pos, u_maskit.lineLeftNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw right line\n        ldot = dot(u_maskit.lineRightPoints.xy - pos, u_maskit.lineRightNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 computeOrbitColor(float n) {\n    return u_maskit.applyInversion ?\n        hsv2rgb(vec3(.5 +0.03 * n, 1., 1.)):\n        hsv2rgb(vec3(0. + 0.03 * (n -1.), 1.0, 1.0));\n}\n\nbool renderOrbit(vec2 pos, out vec3 col){\n    col = vec3(0);\n    for(int i = 0; i < MAX_ORBIT_POINTS; i++) {\n        if(distance(pos, u_maskit.orbitPoints[i]) < u_maskit.ui.x * 1.2) {\n            col = computeOrbitColor(float(i));\n            return true;\n        }\n        if(i > 0) {\n            vec2 p1 = u_maskit.orbitPoints[i - 1];\n            vec2 p2 = u_maskit.orbitPoints[i];\n            vec2 v = p2 - p1;\n            vec2 n = normalize(vec2(-v.y, v.x));\n            vec2 posP1 = pos - p1;\n            vec2 posP2 = pos - p2;\n            if(dot(posP1, posP2) < 0. &&\n               abs(dot(n, posP1)) < u_maskit.ui.y) {\n                /*\n                float dist = distance(p1, p2);\n                float distP1Pos = length(posP1);\n                col = mix(computeOrbitColor(float(i)),\n                          computeOrbitColor(float(i-1)), distP1Pos / dist);\n                */\n                col = computeOrbitColor(float(i));\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// front to back blend\nvec4 blendCol(vec4 srcC, vec4 outC){\n\tsrcC.rgb *= srcC.a;\n\treturn outC + srcC * (1.0 - outC.a);\n}\n\nfloat SAMPLE_NUM = 10.;\nout vec4 outColor;\nvoid main() {\n    vec3 sum = vec3(0);\n\tfloat ratio = u_resolution.x / u_resolution.y / 2.0;\n\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (gl_FragCoord.xy + (rand2n(gl_FragCoord.xy, i))) / u_resolution.yy ) - vec2(ratio, 0.5);\n        position *= u_geometry.z;\n        position += u_geometry.xy;\n\n        vec3 c = BLACK;\n        bool render = renderUI(position, c);\n        if(render) {\n            sum += c;\n            continue;\n        }\n\n        vec4 cc = vec4(0);\n        if(u_maskit.drawCircle) {\n            float dist = distance(position, u_maskit.inversionCircle.xy);\n            float rdist = u_maskit.inversionCircle.z - dist;\n            if(0. < rdist && rdist < u_maskit.ui.z){\n                cc = vec4(0, 1, 0, 0.5);\n            } else if(dist < u_maskit.inversionCircle.z) {\n                cc = vec4(0, 0, 1, 0.5);\n            }\n        }\n\n        if(u_maskit.trackOrbit) {\n            bool render = renderOrbit(position, c);\n            if(render) {\n                sum += c;\n                continue;\n            }\n        }\n\n        if(u_maskit.applyInversion) {\n            sum += blendCol(vec4(josKleinianIIS(position,\n                                                u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        } else {\n            sum += blendCol(vec4(josKleinian(position,\n                                             u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        }\n    }\n    outColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n"},function(e,n,t){"use strict";function i(e){new u;return e.getContext("webgl2")}function r(e,n){var t=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,new Float32Array(n),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),t}function o(e){return r(e,c)}function s(e,n){new u;e.linkProgram(n),e.useProgram(n)}function a(e,n,t,i){var r=(new u,e.createShader(i));e.shaderSource(r,n),e.compileShader(r),e.attachShader(t,r)}Object.defineProperty(n,"__esModule",{value:!0});var u=function(){function e(){this.captured=[]}return e.prototype._capt=function(e,n){return this.captured.push({value:e,espath:n}),e},e.prototype._expr=function(e,n){var t=this.captured;return this.captured=[],{powerAssertContext:{value:e,events:t},source:n}},e}();n.GetWebGL2Context=i,n.CreateStaticVbo=r,n.CreateSquareVbo=o,n.LinkProgram=s,n.AttachShader=a;var c=[-1,-1,-1,1,1,-1,1,1]},function(e,n,t){"use strict";var i=t(2),r=function(e){return e&&e.__esModule?e:{default:e}}(i),o=t(1),s=t(4),a=t(3);window.addEventListener("load",function(){var e=new r.default(2,0,.5),n=new o.MaskitCanvas("canvas",e,s),t=new o.InvertedMaskitCanvas("invCanvas",e,a),i=document.getElementById("drawLineCheck");i.addEventListener("change",function(){e.drawLines=i.checked,n.render(),t.render()});var u=document.getElementById("drawCircleCheck");u.addEventListener("change",function(){e.drawCircle=u.checked,n.render(),t.render()});var c=document.getElementById("drawInnerCheck");c.addEventListener("change",function(){e.drawInner=c.checked,n.render(),t.render()});var l=document.getElementById("applyInversionCheck");l.addEventListener("change",function(){e.applyInversion=l.checked,n.render(),t.render()});var h=document.getElementById("trackOrbitCheck");h.addEventListener("change",function(){e.trackOrbit=h.checked,n.render(),t.render()}),n.render(),t.render()})},function(e,n){e.exports="#version 300 es\n\nin vec2 a_vertex;\nout vec2 v_texCoord;\n\nvoid main() {\n    v_texCoord = a_vertex.xy * 0.5 + 0.5;\n    gl_Position = vec4(a_vertex, 0., 1.0);\n}\n"}]);