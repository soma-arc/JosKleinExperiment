!function(n){function t(i){if(e[i])return e[i].exports;var o=e[i]={i:i,l:!1,exports:{}};return n[i].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var e={};t.m=n,t.c=e,t.i=function(n){return n},t.d=function(n,e,i){t.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:i})},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},t.p="",t(t.s=7)}([function(n,t,e){"use strict";function i(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function n(n,t){for(var e=0;e<t.length;e++){var i=t[e];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}return function(t,e,i){return e&&n(t.prototype,e),i&&n(t,i),t}}(),r=Math.sqrt(2),s=function(){function n(t,e){i(this,n),this.re=t,this.im=e}return o(n,[{key:"add",value:function(t){return new n(this.re+t.re,this.im+t.im)}},{key:"sub",value:function(t){return new n(this.re-t.re,this.im-t.im)}},{key:"mult",value:function(t){return new n(this.re*t.re-this.im*t.im,this.re*t.im+this.im*t.re)}},{key:"div",value:function(t){if(t.isInfinity())return n.ZERO;var e=t.re*t.re+t.im*t.im;return e<1e-7?new n(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY):new n((this.re*t.re+this.im*t.im)/e,(this.im*t.re-this.re*t.im)/e)}},{key:"scale",value:function(t){return new n(this.re*t,this.im*t)}},{key:"arg",value:function(){return Math.atan2(this.im,this.re)}},{key:"conjugate",value:function(){return new n(this.re,-this.im)}},{key:"normalize",value:function(){return this.scale(1/this.abs())}},{key:"abs",value:function(){return Math.sqrt(this.re*this.re+this.im*this.im)}},{key:"absSq",value:function(){return this.re*this.re+this.im*this.im}},{key:"eq",value:function(n){var t=this.re-n.re,e=this.im-n.im;return t*t+e*e<1e-7}},{key:"sq",value:function(){return new n(this.re*this.re-this.im*this.im,this.re*this.im+this.im*this.re)}},{key:"sqrt",value:function(){return this.im>0?new n(Math.sqrt(this.re+Math.sqrt(this.re*this.re+this.im*this.im))/r,Math.sqrt(-this.re+Math.sqrt(this.re*this.re+this.im*this.im))/r):this.i<0?new n(Math.sqrt(this.re+Math.sqrt(this.re*this.re+this.im*this.im))/r,-Math.sqrt(-this.re+Math.sqrt(this.re*this.re+this.im*this.im))/r):this.re<0?new n(0,Math.sqrt(Math.abs(this.re))):new n(Math.sqrt(this.re),0)}},{key:"isInfinity",value:function(){return this.re===Number.POSITIVE_INFINITY||this.im===Number.POSITIVE_INFINITY}},{key:"isZero",value:function(){return Math.abs(this.re)<1e-7&&Math.abs(this.im)<1e-7}},{key:"isReal",value:function(){return Math.abs(this.im)<1e-7}},{key:"isPureImaginary",value:function(){return Math.abs(this.re)<1e-7}},{key:"hasNaN",value:function(){return isNaN(this.re)||isNaN(this.im)}},{key:"linearArray",get:function(){return[this.re,this.im]}}],[{key:"sum",value:function(n,t){return n.add(t)}},{key:"diff",value:function(n,t){return n.sub(t)}},{key:"prod",value:function(n,t){return n.mult(t)}},{key:"quot",value:function(n,t){return n.div(t)}},{key:"conjugate",value:function(n){return n.conjugate()}},{key:"abs",value:function(n){return n.abs()}},{key:"absSq",value:function(n){return n.absSq()}},{key:"eq",value:function(n,t){var e=n.re-t.re,i=n.im-t.im;return e*e+i*i<1e-7}},{key:"distance",value:function(n,t){return n.sub(t).abs()}},{key:"sq",value:function(n){return n.sq()}},{key:"sqrt",value:function(n){return n.sqrt()}},{key:"dot",value:function(n,t){return n.re*t.re+n.im*t.im}},{key:"ZERO",get:function(){return new n(0,0)}},{key:"ONE",get:function(){return new n(1,0)}},{key:"I",get:function(){return new n(0,1)}},{key:"MINUS_ONE",get:function(){return new n(-1,0)}},{key:"INFINITY",get:function(){return new n(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}}]),n}();t.default=s},function(n,t,e){"use strict";function i(n,t){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?n:t}function o(n,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);n.prototype=Object.create(t&&t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(n,t):n.__proto__=t)}function r(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0}),t.Maskit3dCanvas=t.InvertedMaskitCanvas=t.MaskitCanvas=void 0;var s=function(){function n(n,t){for(var e=0;e<t.length;e++){var i=t[e];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}return function(t,e,i){return e&&n(t.prototype,e),i&&n(t,i),t}}(),a=e(6),c=e(0),u=function(n){return n&&n.__esModule?n:{default:n}}(c),l=e(8),v=function(){function n(t,e,i){r(this,n),this.canvasId=t,this.maskit=e,this.fragment=i,this.canvas=document.getElementById(t),this.pixelRatio=window.devicePixelRatio,this.canvas.style.width=this.canvas.width+"px",this.canvas.style.height=this.canvas.height+"px",this.canvas.width=this.canvas.width*this.pixelRatio,this.canvas.height=this.canvas.height*this.pixelRatio,this.canvasRatio=this.canvas.width/this.canvas.height/2,this.gl=(0,a.GetWebGL2Context)(this.canvas),this.setupShader(),this.setUniformLocations(),this.translate=new u.default(0,1),this.scale=2.1,this.kleinIterations=200,this.sceneScaleFactor=1.5}return s(n,[{key:"hideCanvas",value:function(){this.canvas.style.display="none"}},{key:"showCanvas",value:function(){this.canvas.style.display="inline"}},{key:"toggleCanvas",value:function(){"none"===this.canvas.style.display?(this.showCanvas(),this.render()):this.hideCanvas()}},{key:"setupShader",value:function(){this.vertexBuffer=(0,a.CreateSquareVbo)(this.gl),this.renderProgram=this.gl.createProgram(),(0,a.AttachShader)(this.gl,l,this.renderProgram,this.gl.VERTEX_SHADER),(0,a.AttachShader)(this.gl,this.fragment,this.renderProgram,this.gl.FRAGMENT_SHADER),(0,a.LinkProgram)(this.gl,this.renderProgram),this.renderVAttrib=this.gl.getAttribLocation(this.renderProgram,"a_vertex"),this.gl.enableVertexAttribArray(this.renderVAttrib)}},{key:"setUniformLocations",value:function(){this.uniLocations=[],this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_resolution")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_geometry")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_kleinIterations")),this.maskit.setUniformLocations(this.gl,this.uniLocations,this.renderProgram)}},{key:"setUniformValues",value:function(){var n=0;this.gl.uniform2f(this.uniLocations[n++],this.canvas.width,this.canvas.height),this.gl.uniform3f(this.uniLocations[n++],this.translate.re,this.translate.im,this.scale),this.gl.uniform1i(this.uniLocations[n++],this.kleinIterations),n=this.maskit.setUniformValues(this.gl,this.uniLocations,n,this.scale)}},{key:"render",value:function(){"none"!==this.canvas.style.display&&(this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.useProgram(this.renderProgram),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexBuffer),this.gl.vertexAttribPointer(this.renderCanvasVAttrib,2,this.gl.FLOAT,!1,0,0),this.setUniformValues(),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.flush())}},{key:"calcCanvasCoord",value:function(n,t){var e=this.canvas.getBoundingClientRect();return new u.default(this.scale*((n-e.left)*this.pixelRatio/this.canvas.height-this.canvasRatio),this.scale*-((t-e.top)*this.pixelRatio/this.canvas.height-.5))}},{key:"calcSceneCoord",value:function(n,t){return this.calcCanvasCoord(n,t).add(this.translate)}},{key:"setupMouseListener",value:function(){this.mouseState={isPressing:!1,prevPosition:new u.default(0,0),prevTranslate:new u.default(0,0),button:-1},this.boundOnMouseWheel=this.onMouseWheel.bind(this),this.canvas.addEventListener("wheel",this.boundOnMouseWheel),this.boundOnMouseDown=this.onMouseDown.bind(this),this.canvas.addEventListener("mousedown",this.boundOnMouseDown),this.boundOnMouseMove=this.onMouseMove.bind(this),this.canvas.addEventListener("mousemove",this.boundOnMouseMove),this.boundOnMouseUp=this.onMouseUp.bind(this),this.canvas.addEventListener("mouseup",this.boundOnMouseUp),this.canvas.addEventListener("contextmenu",function(n){return n.preventDefault()})}},{key:"onMouseWheel",value:function(n){n.preventDefault(),n.deltaY>0?this.scale*=this.sceneScaleFactor:this.scale/=this.sceneScaleFactor,this.render()}},{key:"onMouseDown",value:function(n){}},{key:"onMouseMove",value:function(n){}},{key:"onMouseUp",value:function(n){this.mouseState.isPressing=!1,this.maskit.release()}}],[{key:"MOUSE_BUTTON_LEFT",get:function(){return 0}},{key:"MOUSE_BUTTON_WHEEL",get:function(){return 1}},{key:"MOUSE_BUTTON_RIGHT",get:function(){return 2}}]),n}();t.MaskitCanvas=function(n){function t(n,e,o){r(this,t);var s=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,n,e,o));return s.maskit.addParameterChangedListener(function(n){s.render()}),s.setupMouseListener(),s}return o(t,n),s(t,[{key:"onMouseDown",value:function(n){n.preventDefault();var t=this.calcSceneCoord(n.clientX,n.clientY);n.button===v.MOUSE_BUTTON_LEFT&&(this.maskit.select(t),this.render()),this.mouseState.prevPosition=t,this.mouseState.prevTranslate=this.translate,this.mouseState.isPressing=!0,this.mouseState.button=n.button}},{key:"onMouseMove",value:function(n){var t=this.calcSceneCoord(n.clientX,n.clientY);this.maskit.updateOrbitPoints(t),this.mouseState.isPressing&&(this.mouseState.button===v.MOUSE_BUTTON_LEFT?this.maskit.move(t):this.mouseState.button===v.MOUSE_BUTTON_RIGHT&&(this.translate=this.translate.sub(t.sub(this.mouseState.prevPosition)),this.render()))}}]),t}(v),t.InvertedMaskitCanvas=function(n){function t(n,e,o){r(this,t);var s=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,n,e,o));return s.maskit.addParameterChangedListener(function(n){s.render()}),s.setupMouseListener(),s}return o(t,n),s(t,[{key:"onMouseDown",value:function(n){n.preventDefault();var t=this.calcSceneCoord(n.clientX,n.clientY);this.mouseState.prevPosition=t,this.mouseState.prevTranslate=this.translate,this.mouseState.isPressing=!0,this.mouseState.button=n.button}},{key:"onMouseMove",value:function(n){if(this.mouseState.isPressing){var t=this.calcSceneCoord(n.clientX,n.clientY);this.mouseState.button===v.MOUSE_BUTTON_RIGHT&&(this.translate=this.translate.sub(t.sub(this.mouseState.prevPosition)),this.render())}}}]),t}(v),t.Maskit3dCanvas=function(n){function t(n,e,o){r(this,t);var s=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,n,e,o));return s.cameraPos=[0,1,1],s.cameraUp=[0,1,0],s.cameraTarget=[0,1,0],s.cameraDistance=2,s.cameraLnglat=[90,0],s.mouseDownLngLat=[0,0],s.setupMouseListener(),s.updateCamera(),s.maskit.addParameterChangedListener(function(n){s.render()}),s}return o(t,n),s(t,[{key:"updateCamera",value:function(){var n=(90-this.cameraLnglat[1])*Math.PI/180,t=this.cameraLnglat[0]*Math.PI/180;this.cameraPos=[this.cameraDistance*Math.sin(n)*Math.cos(t),Math.max(-.9,this.cameraDistance*Math.cos(n)),this.cameraDistance*Math.sin(n)*Math.sin(t)],this.cameraPos=[this.cameraPos[0]+this.cameraTarget[0],this.cameraPos[1]+this.cameraTarget[1],this.cameraPos[2]+this.cameraTarget[2]],this.render()}},{key:"onMouseDown",value:function(n){n.preventDefault();var t=this.calcCanvasCoord(n.clientX,n.clientY);this.mouseState.prevPosition=t,this.mouseState.prevTranslate=this.translate,this.mouseDownLngLat=this.cameraLnglat,this.mouseState.isPressing=!0}},{key:"onMouseMove",value:function(n){if(n.preventDefault(),this.mouseState.isPressing){var t=this.calcCanvasCoord(n.clientX,n.clientY);this.cameraLnglat=[50.5*(this.mouseState.prevPosition.re-t.re)+this.mouseDownLngLat[0],50.5*(t.im-this.mouseState.prevPosition.im)+this.mouseDownLngLat[1]],this.updateCamera()}}},{key:"onMouseWheel",value:function(n){n.preventDefault(),n.deltaY>0?this.cameraDistance*=1.25:this.cameraDistance&&(this.cameraDistance/=1.25),this.updateCamera()}},{key:"setUniformLocations",value:function(){this.uniLocations=[],this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_resolution")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_cameraPos")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_cameraTarget")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_cameraUp")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_kleinIterations")),this.maskit.setUniformLocations(this.gl,this.uniLocations,this.renderProgram)}},{key:"setUniformValues",value:function(){var n=0;this.gl.uniform2f(this.uniLocations[n++],this.canvas.width,this.canvas.height),this.gl.uniform3f(this.uniLocations[n++],this.cameraPos[0],this.cameraPos[1],this.cameraPos[2]),this.gl.uniform3f(this.uniLocations[n++],this.cameraTarget[0],this.cameraTarget[1],this.cameraTarget[2]),this.gl.uniform3f(this.uniLocations[n++],this.cameraUp[0],this.cameraUp[1],this.cameraUp[2]),this.gl.uniform1i(this.uniLocations[n++],this.kleinIterations),n=this.maskit.setUniformValues(this.gl,this.uniLocations,n,this.scale)}}]),t}(v)},function(n,t,e){"use strict";function i(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function n(n,t){for(var e=0;e<t.length;e++){var i=t[e];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}return function(t,e,i){return e&&n(t.prototype,e),i&&n(t,i),t}}(),r=e(0),s=function(n){return n&&n.__esModule?n:{default:n}}(r),a=function(){function n(t,e,o){i(this,n),this.t=new s.default(t,e),this.n=o,this.k=2*Math.cos(Math.PI/this.n),this.update(),this.pointRadius=.03,this.lineWidth=.01,this.circumferenceWidth=.02,this.selectedComponentId=-1,this.diffToComponent=new s.default(0,0),this.invCircleCenter=new s.default(0,1),this.invCircleR=1,this.drawLines=!1,this.drawCircle=!1,this.applyInversion=!0,this.trackOrbit=!1,this.drawInner=!1,this.parameterChangedListener=[],this.maxOrbitPoints=20,this.orbitPoints=new Array(2*this.maxOrbitPoints)}return o(n,[{key:"addParameterChangedListener",value:function(n){this.parameterChangedListener.push(n)}},{key:"onParameterChanged",value:function(){var n=!0,t=!1,e=void 0;try{for(var i,o=this.parameterChangedListener[Symbol.iterator]();!(n=(i=o.next()).done);n=!0){(0,i.value)(this)}}catch(n){t=!0,e=n}finally{try{!n&&o.return&&o.return()}finally{if(t)throw e}}}},{key:"release",value:function(){this.selectedComponentId=-1}},{key:"update",value:function(){this.symmetricalPoint=new s.default(.5*-this.t.im,.5*this.t.re),this.halfK=.5*this.k,this.rightBelowP=new s.default(this.halfK,0),this.leftBelowP=new s.default(-this.halfK,0),this.rightAbobeP=new s.default(this.halfK-this.t.im,this.t.re),this.leftAbobeP=new s.default(-this.halfK-this.t.im,this.t.re);var n=this.rightAbobeP.sub(this.rightBelowP);this.lineRightNormal=new s.default(-n.im,n.re),this.lineLeftNormal=this.lineRightNormal.scale(-1)}},{key:"updateOrbitPoints",value:function(n){this.trackOrbit&&(this.orbitPoints=this.computeOrbit(n,this.maxOrbitPoints),this.onParameterChanged())}},{key:"select",value:function(t){var e=t.sub(this.rightAbobeP);if(e.abs()<this.pointRadius)return this.selectedComponentId=n.POINT_RIGHT_ABOVE,this.diffToComponent=e,!0;var i=t.sub(this.rightBelowP);if(i.abs()<this.pointRadius)return this.selectedComponentId=n.POINT_RIGHT_BELOW,this.diffToComponent=i,!0;var o=t.sub(this.leftAbobeP);if(o.abs()<this.pointRadius)return this.selectedComponentId=n.POINT_LEFT_ABOVE,this.diffToComponent=o,!0;var r=t.sub(this.leftBelowP);if(r.abs()<this.pointRadius)return this.selectedComponentId=n.POINT_LEFT_BELOW,this.diffToComponent=r,!0;var a=t.sub(this.symmetricalPoint);if(a.abs()<this.pointRadius)return this.selectedComponentId=n.POINT_SYMMETRICAL,this.diffToComponent=a,!0;if(!this.drawCircle)return!1;var c=t.sub(this.invCircleCenter),u=c.abs(),l=this.invCircleR-u;return 0<l&&l<this.circumferenceWidth?(this.selectedComponentId=n.INVERSION_CIRCLE_CIRCUMFERENCE,this.diffToComponent=new s.default(l,l),!0):u<this.invCircleR&&(this.selectedComponentId=n.INVERSION_CIRCLE_BODY,this.diffToComponent=c,!0)}},{key:"move",value:function(t){switch(this.selectedComponentId){case n.POINT_RIGHT_ABOVE:var e=t.sub(this.diffToComponent);this.t=new s.default(e.im,this.halfK-e.re);break;case n.POINT_RIGHT_BELOW:var i=t.sub(this.diffToComponent);this.k=2*i.re;break;case n.POINT_LEFT_ABOVE:var o=t.sub(this.diffToComponent);this.t=new s.default(o.im,-this.halfK-o.re);break;case n.POINT_LEFT_BELOW:var r=t.sub(this.diffToComponent);this.k=2*r.re;break;case n.POINT_SYMMETRICAL:var a=t.sub(this.diffToComponent);this.t=new s.default(2*a.im,2*-a.re);break;case n.INVERSION_CIRCLE_BODY:this.invCircleCenter=t.sub(this.diffToComponent);break;case n.INVERSION_CIRCLE_CIRCUMFERENCE:this.invCircleR=s.default.distance(this.invCircleCenter,t)+this.diffToComponent.re;break;default:return!1}return this.update(),this.onParameterChanged(),!0}},{key:"lineY",value:function(n,t){return.5*t.re+Math.sign(.5*t.im)*(2*t.re-1.95)/4*Math.sign(n.re+.5*t.im)*(1-Math.exp(-(7.2-15*(1.95-t.re))*Math.abs(n.re+.5*t.im)))}},{key:"transA",value:function(n,t){var e=1/n.absSq(),i=n.scale(-e);return i.re=-t.im-i.re,i.im=t.re+i.im,i}},{key:"computeOrbit",value:function(n,t){for(var e=[n],i=1,o=new s.default(n.re,n.im),r=0;r<100;r++){var a=this.k/2+this.t.im*o.im/this.t.re;if((o.re<-a||a<o.re)&&(o.re+=a,o.re=o.re-this.k*Math.floor(o.re/this.k),o.re-=a,e.push(new s.default(o.re,o.im)),++i===t))break;if(o.im>=this.lineY(o,this.t)&&(o=new s.default(-this.t.im,this.t.re).sub(o),e.push(new s.default(o.re,o.im)),++i===t))break;if(o=this.transA(o,this.t),e.push(new s.default(o.re,o.im)),++i===t)break;if(o.im<0||this.t.re<o.im){for(var c=e[i-1],u=i;u<t;u++)e.push(c);break}}for(var l=new Array(2*t),v=0;v<t;v++)l[2*v+0]=e[v].re,l[2*v+1]=e[v].im;return l}},{key:"setUniformLocations",value:function(n,t,e){t.push(n.getUniformLocation(e,"u_maskit.uv")),t.push(n.getUniformLocation(e,"u_maskit.k")),t.push(n.getUniformLocation(e,"u_maskit.symmetricalPoint")),t.push(n.getUniformLocation(e,"u_maskit.lineLeftNormal")),t.push(n.getUniformLocation(e,"u_maskit.lineLeftPoints")),t.push(n.getUniformLocation(e,"u_maskit.lineRightNormal")),t.push(n.getUniformLocation(e,"u_maskit.lineRightPoints")),t.push(n.getUniformLocation(e,"u_maskit.inversionCircle")),t.push(n.getUniformLocation(e,"u_maskit.ui")),t.push(n.getUniformLocation(e,"u_maskit.drawLines")),t.push(n.getUniformLocation(e,"u_maskit.drawCircle")),t.push(n.getUniformLocation(e,"u_maskit.drawInner")),t.push(n.getUniformLocation(e,"u_maskit.applyInversion")),t.push(n.getUniformLocation(e,"u_maskit.trackOrbit")),t.push(n.getUniformLocation(e,"u_maskit.orbitPoints"))}},{key:"setUniformValues",value:function(n,t,e,i){var o=e;return n.uniform2f(t[o++],this.t.re,this.t.im),n.uniform1f(t[o++],this.k),n.uniform2f(t[o++],this.symmetricalPoint.re,this.symmetricalPoint.im),n.uniform2f(t[o++],this.lineLeftNormal.re,this.lineLeftNormal.im),n.uniform4f(t[o++],this.leftBelowP.re,this.leftBelowP.im,this.leftAbobeP.re,this.leftAbobeP.im),n.uniform2f(t[o++],this.lineRightNormal.re,this.lineRightNormal.im),n.uniform4f(t[o++],this.rightBelowP.re,this.rightBelowP.im,this.rightAbobeP.re,this.rightAbobeP.im),n.uniform4f(t[o++],this.invCircleCenter.re,this.invCircleCenter.im,this.invCircleR,this.invCircleR*this.invCircleR),n.uniform3f(t[o++],this.pointRadius,this.lineWidth,this.circumferenceWidth),n.uniform1i(t[o++],this.drawLines),n.uniform1i(t[o++],this.drawCircle),n.uniform1i(t[o++],this.drawInner),n.uniform1i(t[o++],this.applyInversion),n.uniform1i(t[o++],this.trackOrbit),n.uniform2fv(t[o++],this.orbitPoints),o}}],[{key:"POINT_RIGHT_ABOVE",get:function(){return 0}},{key:"POINT_RIGHT_BELOW",get:function(){return 1}},{key:"POINT_LEFT_ABOVE",get:function(){return 2}},{key:"POINT_LEFT_BELOW",get:function(){return 3}},{key:"POINT_SYMMETRICAL",get:function(){return 4}},{key:"INVERSION_CIRCLE_BODY",get:function(){return 5}},{key:"INVERSION_CIRCLE_CIRCUMFERENCE",get:function(){return 6}}]),n}();t.default=a},function(n,t){n.exports="#version 300 es\nprecision mediump float;\n\nconst int MAX_ORBIT_POINTS = 20;\nstruct Maskit {\n    vec2 uv;\n    float k;\n    vec2 symmetricalPoint;\n    vec2 lineLeftNormal;\n    vec4 lineLeftPoints; // [below, above]\n    vec2 lineRightNormal;\n    vec4 lineRightPoints;\n    vec4 inversionCircle;\n    vec3 ui; // [point radius, line width, circumference width]\n    bool drawLines;\n    bool drawCircle;\n    bool drawInner;\n    bool applyInversion;\n    bool trackOrbit;\n    vec2 orbitPoints[MAX_ORBIT_POINTS];\n};\n\n\nuniform vec2 u_resolution;\nuniform vec3 u_geometry; // [translateX, translateY, scale]\nuniform int u_kleinIterations;\nuniform Maskit u_maskit;\n\nconst vec3 BLACK = vec3(0, 0, 0.01);\nconst vec3 WHITE = vec3(1);\nconst vec3 RED = vec3(0.8, 0, 0);\nconst vec3 GREEN = vec3(0, 0.8, 0);\nconst vec3 BLUE = vec3(0, 0, 0.8);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 circleInvert(const vec2 pos, const vec4 circle){\n    vec2 p = pos - circle.xy;\n    float d = length(p);\n    return (p * circle.w)/(d * d) + circle.xy;\n}\n\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec2 TransA(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x; z.y = uv.x + z.y;\n    return z;\n}\n\nvec2 TransAInv(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z + vec2(uv.y,-uv.x), z + vec2(uv.y, -uv.x));\n\tz.x += uv.y; z.y = uv.x - z.y;\n\tz *= iR;\n    return z;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 computeColor(float n){\n\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n}\n\nvec3 computeColor2(float n, float numTransA) {\n    if(n == 0.) {\n        return u_maskit.drawInner ? computeColor(numTransA) : BLACK;\n    }\n    return hsv2rgb(vec3(0. + 0.05 * (n -1.), 1.0, 1.0));\n}\n\nconst int LOOP_NUM = 200;\nvec3 josKleinian(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        loopNum++;\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6)\n            return u_maskit.drawInner ?\n                hsv2rgb(vec3(0.01 * (loopNum-1.), 1., 1.)) :\n                BLACK;\n\n        if(pos.y <= 0. || uv.x < pos.y) {\n        \treturn computeColor(loopNum);\n        }\n\n        llz=lz; lz=pos;\n    }\n    return BLACK;\n}\n\nvec3 josKleinianIIS(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        numTransA++;\n        if(uv.x < pos.y) {\n            pos.y -= uv.x;\n            pos.y *= -1.;\n            pos.y += uv.x;\n            loopNum++;\n        }\n        if(pos.y <= 0.){\n            pos.y *= -1.;\n            loopNum++;\n        }\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) return computeColor2(loopNum, numTransA);\n\n        llz=lz; lz=pos;\n    }\n    return computeColor2(loopNum, numTransA);\n}\n\nbool renderUI(vec2 pos, out vec3 col){\n    col = BLACK;\n\n    if (distance(pos, u_maskit.symmetricalPoint) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    }\n\n    if(u_maskit.drawLines) {\n        // draw line3\n        if(abs(pos.y - lineY(pos, u_maskit.uv)) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw left line\n        float ldot = dot(u_maskit.lineLeftPoints.xy - pos, u_maskit.lineLeftNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw right line\n        ldot = dot(u_maskit.lineRightPoints.xy - pos, u_maskit.lineRightNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n    }\n    return false;\n}\n\n// front to back blend\nvec4 blendCol(vec4 srcC, vec4 outC){\n\tsrcC.rgb *= srcC.a;\n\treturn outC + srcC * (1.0 - outC.a);\n}\n\nfloat SAMPLE_NUM = 10.;\nout vec4 outColor;\nvoid main() {\n    vec3 sum = vec3(0);\n\tfloat ratio = u_resolution.x / u_resolution.y / 2.0;\n\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (gl_FragCoord.xy + (rand2n(gl_FragCoord.xy, i))) / u_resolution.yy ) - vec2(ratio, 0.5);\n        position *= u_geometry.z;\n        position += u_geometry.xy;\n\n        vec4 cc = vec4(0);\n        if(u_maskit.drawCircle) {\n            if(distance(position, u_maskit.inversionCircle.xy) < u_maskit.inversionCircle.z) {\n                cc = vec4(0, 0, 1., 0.5);\n            }\n        }\n\n        position = circleInvert(position, u_maskit.inversionCircle);\n        if(u_maskit.drawLines) {\n            vec3 c = BLACK;\n            bool render = renderUI(position, c);\n            if(render) {\n                sum += c;\n                continue;\n            }\n        }\n\n        if(u_maskit.applyInversion) {\n            sum += blendCol(vec4(josKleinianIIS(position,\n                                                u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        } else {\n            sum += blendCol(vec4(josKleinian(position,\n                                             u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        }\n    }\n    outColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n"},function(n,t){n.exports="#version 300 es\nprecision mediump float;\n\nconst int MAX_ORBIT_POINTS = 20;\nstruct Maskit {\n    vec2 uv;\n    float k;\n    vec2 symmetricalPoint;\n    vec2 lineLeftNormal;\n    vec4 lineLeftPoints; // [below, above]\n    vec2 lineRightNormal;\n    vec4 lineRightPoints;\n    vec4 inversionCircle;\n    vec3 ui; // [point radius, line width, circumference width]\n    bool drawLines;\n    bool drawCircle;\n    bool drawInner;\n    bool applyInversion;\n    bool trackOrbit;\n    vec2 orbitPoints[MAX_ORBIT_POINTS];\n};\n\nuniform vec2 u_resolution;\nuniform vec3 u_geometry; // [translateX, translateY, scale]\nuniform int u_kleinIterations;\nuniform Maskit u_maskit;\n\nconst vec3 BLACK = vec3(0, 0, 0.0);\nconst vec3 WHITE = vec3(1);\nconst vec3 RED = vec3(0.8, 0, 0);\nconst vec3 GREEN = vec3(0, 0.8, 0);\nconst vec3 BLUE = vec3(0, 0, 0.8);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 circleInvert(const vec2 pos, const vec4 circle){\n    vec2 p = pos - circle.xy;\n    float d = length(p);\n    return (p * circle.w)/(d * d) + circle.xy;\n}\n\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec2 TransA(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x; z.y = uv.x + z.y;\n    return z;\n}\n\nvec2 TransAInv(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z + vec2(uv.y,-uv.x), z + vec2(uv.y, -uv.x));\n\tz.x += uv.y; z.y = uv.x - z.y;\n\tz *= iR;\n    return z;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 computeColor(float n){\n\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n}\n\nvec3 computeColor2(float n, float numTransA) {\n    if(n == 0.) {\n        return u_maskit.drawInner ? computeColor(numTransA) : BLACK;\n    }\n    return hsv2rgb(vec3(0. + 0.05 * (n -1.), 1.0, 1.0));\n}\n\nconst int LOOP_NUM = 200;\nvec3 josKleinian(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        loopNum++;\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6)\n            return u_maskit.drawInner ?\n                hsv2rgb(vec3(0.01 * (loopNum-1.), 1., 1.)) :\n                BLACK;\n\n        if(pos.y <= 0. || uv.x < pos.y) {\n        \treturn computeColor(loopNum);\n        }\n\n        llz=lz; lz=pos;\n    }\n    return BLACK;\n}\n\nvec3 josKleinianIIS(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        numTransA++;\n        if(uv.x < pos.y) {\n            pos.y -= uv.x;\n            pos.y *= -1.;\n            pos.y += uv.x;\n            loopNum++;\n        }\n        if(pos.y <= 0.){\n            pos.y *= -1.;\n            loopNum++;\n        }\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) return computeColor2(loopNum, numTransA);\n\n        llz=lz; lz=pos;\n    }\n    return computeColor2(loopNum, numTransA);\n}\n\nbool renderUI(vec2 pos, out vec3 col){\n    col = BLACK;\n\n    if (distance(pos, u_maskit.symmetricalPoint) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    }\n\n    if(u_maskit.drawLines) {\n        // draw line3\n        if(abs(pos.y - lineY(pos, u_maskit.uv)) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw left line\n        float ldot = dot(u_maskit.lineLeftPoints.xy - pos, u_maskit.lineLeftNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw right line\n        ldot = dot(u_maskit.lineRightPoints.xy - pos, u_maskit.lineRightNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 computeOrbitColor(float n) {\n    return u_maskit.applyInversion ?\n        hsv2rgb(vec3(.5 +0.03 * n, 1., 1.)):\n        hsv2rgb(vec3(0. + 0.03 * (n -1.), 1.0, 1.0));\n}\n\nbool renderOrbit(vec2 pos, out vec3 col){\n    col = vec3(0);\n    for(int i = 0; i < MAX_ORBIT_POINTS; i++) {\n        if(distance(pos, u_maskit.orbitPoints[i]) < u_maskit.ui.x * 1.2) {\n            col = computeOrbitColor(float(i));\n            return true;\n        }\n        if(i > 0) {\n            vec2 p1 = u_maskit.orbitPoints[i - 1];\n            vec2 p2 = u_maskit.orbitPoints[i];\n            vec2 v = p2 - p1;\n            vec2 n = normalize(vec2(-v.y, v.x));\n            vec2 posP1 = pos - p1;\n            vec2 posP2 = pos - p2;\n            if(dot(posP1, posP2) < 0. &&\n               abs(dot(n, posP1)) < u_maskit.ui.y) {\n                /*\n                float dist = distance(p1, p2);\n                float distP1Pos = length(posP1);\n                col = mix(computeOrbitColor(float(i)),\n                          computeOrbitColor(float(i-1)), distP1Pos / dist);\n                */\n                col = computeOrbitColor(float(i));\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// front to back blend\nvec4 blendCol(vec4 srcC, vec4 outC){\n\tsrcC.rgb *= srcC.a;\n\treturn outC + srcC * (1.0 - outC.a);\n}\n\nfloat SAMPLE_NUM = 10.;\nout vec4 outColor;\nvoid main() {\n    vec3 sum = vec3(0);\n\tfloat ratio = u_resolution.x / u_resolution.y / 2.0;\n\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (gl_FragCoord.xy + (rand2n(gl_FragCoord.xy, i))) / u_resolution.yy ) - vec2(ratio, 0.5);\n        position *= u_geometry.z;\n        position += u_geometry.xy;\n\n        vec3 c = BLACK;\n        bool render = renderUI(position, c);\n        if(render) {\n            sum += c;\n            continue;\n        }\n\n        vec4 cc = vec4(0);\n        if(u_maskit.drawCircle) {\n            float dist = distance(position, u_maskit.inversionCircle.xy);\n            float rdist = u_maskit.inversionCircle.z - dist;\n            if(0. < rdist && rdist < u_maskit.ui.z){\n                cc = vec4(0, 1, 0, 0.5);\n            } else if(dist < u_maskit.inversionCircle.z) {\n                cc = vec4(0, 0, 1, 0.5);\n            }\n        }\n\n        if(u_maskit.trackOrbit) {\n            bool render = renderOrbit(position, c);\n            if(render) {\n                sum += c;\n                continue;\n            }\n        }\n\n        if(u_maskit.applyInversion) {\n            sum += blendCol(vec4(josKleinianIIS(position,\n                                                u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        } else {\n            sum += blendCol(vec4(josKleinian(position,\n                                             u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        }\n    }\n    outColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n"},function(n,t){n.exports="#version 300 es\nprecision mediump float;\n\nconst int MAX_ORBIT_POINTS = 20;\nstruct Maskit {\n    vec2 uv;\n    float k;\n    vec2 symmetricalPoint;\n    vec2 lineLeftNormal;\n    vec4 lineLeftPoints; // [below, above]\n    vec2 lineRightNormal;\n    vec4 lineRightPoints;\n    vec4 inversionCircle;\n    vec3 ui; // [point radius, line width, circumference width]\n    bool drawLines;\n    bool drawCircle;\n    bool drawInner;\n    bool applyInversion;\n    bool trackOrbit;\n    vec2 orbitPoints[MAX_ORBIT_POINTS];\n};\n\nuniform vec2 u_resolution;\nuniform vec3 u_geometry; // [translateX, translateY, scale]\nuniform vec3 u_cameraPos;\nuniform vec3 u_cameraTarget;\nuniform vec3 u_cameraUp;\nuniform int u_kleinIterations;\nuniform Maskit u_maskit;\n\nconst vec3 BLACK = vec3(0, 0, 0.0);\nconst vec3 WHITE = vec3(1);\nconst vec3 RED = vec3(0.8, 0, 0);\nconst vec3 GREEN = vec3(0, 0.8, 0);\nconst vec3 BLUE = vec3(0, 0, 0.8);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst float OBJ_KLEIN = 0.;\nconst float OBJ_PLANE = 1.;\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1, out bool inBox) {\n\tfloat t0 = -1000000.0, t1 = 1000000.0;\n    hit0 = t0;\n    hit1 = t1;\n    inBox = false;\n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    \n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    \n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1 && 0. < t1) {\n        if(t0 < 0.) inBox = true;\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const vec2 resolution, const vec2 coord){\n    float imagePlane = (resolution.y * .5) / tan(fov * .5);\n    vec3 v = normalize(target - eye);\n    vec3 xaxis = normalize(cross(v, up));\n    vec3 yaxis =  normalize(cross(v, xaxis));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (xaxis * (resolution.x  *.5)) - (yaxis * (resolution.y * .5));\n    return normalize(origin + (xaxis * coord.x) + (yaxis * (resolution.y - coord.y)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec3 TransA(vec3 z, vec2 uv, inout float dr){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x;\n    z.y = uv.x + z.y;\n    dr *= iR;\n    return z;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 distPlane(vec3 p, vec4 n) {\n    return vec4(OBJ_PLANE, dot(p, n.xyz) + n.w, 0, 0);\n}\n\nconst int LOOP_NUM = 20;\nvec4 JosKleinian(vec3 pos, const vec2 uv, const float translation) {\n    float loopNum = 0.;\n    vec3 lz = pos + vec3(1.);\n    vec3 llz = pos + vec3(-1.);\n    float numTransA = 0.;\n    float dr = 1.;\n\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos.xy, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec3(-uv.y, uv.x, 0) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv, dr);\n        loopNum++;\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) break;\n\n        llz=lz; lz=pos;\n    }\n\n    float y =  min(pos.y, uv.x - pos.y) ;\n    float d = 9999999.;\n\td = min(d, min(y, 0.3) / max(dr, 2.));\n    const float scalingFactor = 0.5;\n    return vec4(OBJ_KLEIN, d * scalingFactor, loopNum, numTransA);\n}\n\nvec4 opUnion(vec4 d1, vec4 d2) {\n    return d1.y < d2.y ? d1 : d2;\n}\n    \n\n// return [objId, distance, data, data]\nvec4 distFunc(const vec3 p){\n    vec4 d = distPlane(p, vec4(0, 1, 0, -0.001));\n    return (JosKleinian(p, u_maskit.uv, u_maskit.k));\n}\n\nconst vec2 NORMAL_COEFF = vec2(0.01, 0.);\nvec3 computeNormal(const vec3 p) {\n    return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy).y - distFunc(p - NORMAL_COEFF.xyy).y,\n                          distFunc(p + NORMAL_COEFF.yxy).y - distFunc(p - NORMAL_COEFF.yxy).y,\n                          distFunc(p + NORMAL_COEFF.yyx).y - distFunc(p - NORMAL_COEFF.yyx).y));\n}\n\nconst float EPSILON = 0.001;\nconst int MAX_MARCHING_LOOP = 500;\nvec4 march (const vec3 rayOrg, const vec3 rayDir,\n            const float t0, const float t1,\n            inout vec3 intersection, inout vec3 normal) {\n    vec3 rayPos = rayOrg + rayDir * t0;\n    vec4 dist = vec4(-1);\n    float rayLength = t0;\n    for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n        if(rayLength > t1) break;\n        dist = distFunc(rayPos);\n        rayLength += dist.y;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.y < EPSILON) {\n            intersection = rayPos;\n            normal = computeNormal(intersection);\n            dist.y = rayLength;\n            return dist; // [objId, distance from rayOrigin, data, data]\n        }\n    }\n    return vec4(-1);\n}\n\nfloat computeShadowFactor (const vec3 rayOrg, const vec3 rayDir,\n                           const float mint, const float maxt, const float k) {\n    float shadowFactor = 1.0;\n    for(float t = mint ; t < maxt ;){\n        float d = distFunc(rayOrg + rayDir * t).y;\n        if(d < EPSILON) {\n            shadowFactor = 0.;\n            break;\n        }\n\n        shadowFactor = min(shadowFactor, k * d / t);\n        t += d;\n    }\n    return clamp(shadowFactor, 0.0, 1.0);\n}\n\nvec3 computeColor(float n){\n\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n}\n\nconst vec3 AMBIENT_FACTOR = vec3(0.1);\nconst vec3 LIGHT_DIR = normalize(vec3(1, .8, 1));\nvec3 calcColor(vec3 rayOrg, vec3 rayDir) {\n    float minDist = 9999999.;\n    vec3 intersection, normal;\n    vec3 color = vec3(0);\n\n    float hit0, hit1;\n    bool inBox;\n    bool hit = intersectBox(rayOrg, rayDir,\n                            vec3(-999, -999, -0.6), vec3(999., 999., 0.6),\n                            hit0, hit1, inBox);\n    hit0 = (inBox) ? 0. : hit0;\n\n    vec4 hitInfo = vec4(-1);\n    if(hit){    \n        hitInfo = march(rayOrg, rayDir, hit0, hit1,\n                        intersection, normal);\n    }\n    \n    if(hitInfo.x != -1.) {\n        vec3 matColor;\n        float k = 1.;\n        if(hitInfo.x == OBJ_KLEIN) {\n            matColor = computeColor(hitInfo.z);\n            //matColor = normal;\n            k = 1.;\n            k = computeShadowFactor(intersection + 0.01 * normal, LIGHT_DIR,\n                                    0.1, 1., 30.);\n        } else if(hitInfo.x == OBJ_PLANE) {\n            matColor = normal;//vec3(0.7);\n            k = computeShadowFactor(intersection + 0.01 * normal, LIGHT_DIR,\n                                    0.1, .5, 2.);\n        }\n\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n        vec3 ambient = matColor * AMBIENT_FACTOR;\n        color = (diffuse * k + ambient);\n    }\n    //color = mix( vec3(0.6, 0.7, 1.0), color, exp( -0.01 * minDist * minDist) );\n    return color;\n}\n\nconst float SAMPLE_NUM = 1.;\nout vec4 outColor;\nvoid main() {\n    const float fov = radians(60.);\n    vec3 sum = vec3(0);\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n        vec3 ray = calcRay(u_cameraPos, u_cameraTarget, u_cameraUp, fov,\n                           u_resolution,\n                           gl_FragCoord.xy + coordOffset);\n\n        sum += calcColor(u_cameraPos, ray);\n    }\n    outColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n"},function(n,t,e){"use strict";function i(n){new c;return n.getContext("webgl2")}function o(n,t){var e=n.createBuffer();return n.bindBuffer(n.ARRAY_BUFFER,e),n.bufferData(n.ARRAY_BUFFER,new Float32Array(t),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),e}function r(n){return o(n,u)}function s(n,t){new c;n.linkProgram(t),n.useProgram(t)}function a(n,t,e,i){var o=(new c,n.createShader(i));n.shaderSource(o,t),n.compileShader(o),n.attachShader(e,o)}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function n(){this.captured=[]}return n.prototype._capt=function(n,t){return this.captured.push({value:n,espath:t}),n},n.prototype._expr=function(n,t){var e=this.captured;return this.captured=[],{powerAssertContext:{value:n,events:e},source:t}},n}();t.GetWebGL2Context=i,t.CreateStaticVbo=o,t.CreateSquareVbo=r,t.LinkProgram=s,t.AttachShader=a;var u=[-1,-1,-1,1,1,-1,1,1]},function(n,t,e){"use strict";var i=e(2),o=function(n){return n&&n.__esModule?n:{default:n}}(i),r=e(1),s=e(4),a=e(3),c=e(5);window.addEventListener("load",function(){var n=new o.default(2,0,.5),t=new r.MaskitCanvas("canvas",n,s),e=new r.InvertedMaskitCanvas("invCanvas",n,a),i=new r.Maskit3dCanvas("3dCanvas",n,c),u=document.getElementById("drawLineCheck");u.addEventListener("change",function(){n.drawLines=u.checked,t.render(),e.render()});var l=document.getElementById("drawCircleCheck");l.addEventListener("change",function(){n.drawCircle=l.checked,t.render(),e.render()});var v=document.getElementById("drawInnerCheck");v.addEventListener("change",function(){n.drawInner=v.checked,t.render(),e.render()});var h=document.getElementById("applyInversionCheck");h.addEventListener("change",function(){n.applyInversion=h.checked,t.render(),e.render()});var m=document.getElementById("trackOrbitCheck");m.addEventListener("change",function(){n.trackOrbit=m.checked,t.render(),e.render()}),document.getElementById("view3dCheck").addEventListener("change",function(){i.toggleCanvas(),e.toggleCanvas()}),t.render(),e.render(),i.render()})},function(n,t){n.exports="#version 300 es\n\nin vec2 a_vertex;\nout vec2 v_texCoord;\n\nvoid main() {\n    v_texCoord = a_vertex.xy * 0.5 + 0.5;\n    gl_Position = vec4(a_vertex, 0., 1.0);\n}\n"}]);