!function(n){function e(n){delete installedChunks[n]}function t(n){var e=document.getElementsByTagName("head")[0],t=document.createElement("script");t.type="text/javascript",t.charset="utf-8",t.src=f.p+""+n+"."+x+".hot-update.js",e.appendChild(t)}function i(){return new Promise(function(n,e){if("undefined"==typeof XMLHttpRequest)return e(new Error("No browser support"));try{var t=new XMLHttpRequest,i=f.p+""+x+".hot-update.json";t.open("GET",i,!0),t.timeout=1e4,t.send(null)}catch(n){return e(n)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)e(new Error("Manifest request to "+i+" timed out."));else if(404===t.status)n();else if(200!==t.status&&304!==t.status)e(new Error("Manifest request to "+i+" failed."));else{try{var o=JSON.parse(t.responseText)}catch(n){return void e(n)}n(o)}}})}function o(n){var e=N[n];if(!e)return f;var t=function(t){return e.hot.active?(N[t]?N[t].parents.indexOf(n)<0&&N[t].parents.push(n):(C=[n],m=t),e.children.indexOf(t)<0&&e.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+n),C=[]),f(t)};for(var i in f)Object.prototype.hasOwnProperty.call(f,i)&&"e"!==i&&Object.defineProperty(t,i,function(n){return{configurable:!0,enumerable:!0,get:function(){return f[n]},set:function(e){f[n]=e}}}(i));return t.e=function(n){function e(){L--,"prepare"===I&&(M[n]||l(n),0===L&&0===P&&v())}return"ready"===I&&s("prepare"),L++,f.e(n).then(e,function(n){throw e(),n})},t}function r(n){var e={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],_main:m!==n,active:!0,accept:function(n,t){if(void 0===n)e._selfAccepted=!0;else if("function"==typeof n)e._selfAccepted=n;else if("object"==typeof n)for(var i=0;i<n.length;i++)e._acceptedDependencies[n[i]]=t||function(){};else e._acceptedDependencies[n]=t||function(){}},decline:function(n){if(void 0===n)e._selfDeclined=!0;else if("object"==typeof n)for(var t=0;t<n.length;t++)e._declinedDependencies[n[t]]=!0;else e._declinedDependencies[n]=!0},dispose:function(n){e._disposeHandlers.push(n)},addDisposeHandler:function(n){e._disposeHandlers.push(n)},removeDisposeHandler:function(n){var t=e._disposeHandlers.indexOf(n);t>=0&&e._disposeHandlers.splice(t,1)},check:c,apply:h,status:function(n){if(!n)return I;k.push(n)},addStatusHandler:function(n){k.push(n)},removeStatusHandler:function(n){var e=k.indexOf(n);e>=0&&k.splice(e,1)},data:b[n]};return m=void 0,e}function s(n){I=n;for(var e=0;e<k.length;e++)k[e].call(null,n)}function a(n){return+n+""===n?+n:n}function c(n){if("idle"!==I)throw new Error("check() is only allowed in idle status");return _=n,s("check"),i().then(function(n){if(!n)return s("idle"),null;w={},M={},A=n.c,g=n.h,s("prepare");var e=new Promise(function(n,e){p={resolve:n,reject:e}});y={};return l(0),"prepare"===I&&0===L&&0===P&&v(),e})}function u(n,e){if(A[n]&&w[n]){w[n]=!1;for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(y[t]=e[t]);0==--P&&0===L&&v()}}function l(n){A[n]?(w[n]=!0,P++,t(n)):M[n]=!0}function v(){s("ready");var n=p;if(p=null,n)if(_)h(_).then(function(e){n.resolve(e)},function(e){n.reject(e)});else{var e=[];for(var t in y)Object.prototype.hasOwnProperty.call(y,t)&&e.push(a(t));n.resolve(e)}}function h(t){function i(n,e){for(var t=0;t<e.length;t++){var i=e[t];n.indexOf(i)<0&&n.push(i)}}if("ready"!==I)throw new Error("apply() is only allowed in ready status");t=t||{};var o,r,c,u,l,v={},h=[],d={},m=function(){console.warn("[HMR] unexpected require("+_.moduleId+") to disposed module")};for(var p in y)if(Object.prototype.hasOwnProperty.call(y,p)){l=a(p);var _;_=y[p]?function(n){for(var e=[n],t={},o=e.slice().map(function(n){return{chain:[n],id:n}});o.length>0;){var r=o.pop(),s=r.id,a=r.chain;if((u=N[s])&&!u.hot._selfAccepted){if(u.hot._selfDeclined)return{type:"self-declined",chain:a,moduleId:s};if(u.hot._main)return{type:"unaccepted",chain:a,moduleId:s};for(var c=0;c<u.parents.length;c++){var l=u.parents[c],v=N[l];if(v){if(v.hot._declinedDependencies[s])return{type:"declined",chain:a.concat([l]),moduleId:s,parentId:l};e.indexOf(l)>=0||(v.hot._acceptedDependencies[s]?(t[l]||(t[l]=[]),i(t[l],[s])):(delete t[l],e.push(l),o.push({chain:a.concat([l]),id:l})))}}}}return{type:"accepted",moduleId:n,outdatedModules:e,outdatedDependencies:t}}(l):{type:"disposed",moduleId:p};var O=!1,k=!1,P=!1,L="";switch(_.chain&&(L="\nUpdate propagation: "+_.chain.join(" -> ")),_.type){case"self-declined":t.onDeclined&&t.onDeclined(_),t.ignoreDeclined||(O=new Error("Aborted because of self decline: "+_.moduleId+L));break;case"declined":t.onDeclined&&t.onDeclined(_),t.ignoreDeclined||(O=new Error("Aborted because of declined dependency: "+_.moduleId+" in "+_.parentId+L));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(_),t.ignoreUnaccepted||(O=new Error("Aborted because "+l+" is not accepted"+L));break;case"accepted":t.onAccepted&&t.onAccepted(_),k=!0;break;case"disposed":t.onDisposed&&t.onDisposed(_),P=!0;break;default:throw new Error("Unexception type "+_.type)}if(O)return s("abort"),Promise.reject(O);if(k){d[l]=y[l],i(h,_.outdatedModules);for(l in _.outdatedDependencies)Object.prototype.hasOwnProperty.call(_.outdatedDependencies,l)&&(v[l]||(v[l]=[]),i(v[l],_.outdatedDependencies[l]))}P&&(i(h,[_.moduleId]),d[l]=m)}var M=[];for(r=0;r<h.length;r++)l=h[r],N[l]&&N[l].hot._selfAccepted&&M.push({module:l,errorHandler:N[l].hot._selfAccepted});s("dispose"),Object.keys(A).forEach(function(n){!1===A[n]&&e(n)});for(var w,E=h.slice();E.length>0;)if(l=E.pop(),u=N[l]){var F={},T=u.hot._disposeHandlers;for(c=0;c<T.length;c++)(o=T[c])(F);for(b[l]=F,u.hot.active=!1,delete N[l],c=0;c<u.children.length;c++){var R=N[u.children[c]];R&&((w=R.parents.indexOf(l))>=0&&R.parents.splice(w,1))}}var z,S;for(l in v)if(Object.prototype.hasOwnProperty.call(v,l)&&(u=N[l]))for(S=v[l],c=0;c<S.length;c++)z=S[c],(w=u.children.indexOf(z))>=0&&u.children.splice(w,1);s("apply"),x=g;for(l in d)Object.prototype.hasOwnProperty.call(d,l)&&(n[l]=d[l]);var U=null;for(l in v)if(Object.prototype.hasOwnProperty.call(v,l)){u=N[l],S=v[l];var B=[];for(r=0;r<S.length;r++)z=S[r],o=u.hot._acceptedDependencies[z],B.indexOf(o)>=0||B.push(o);for(r=0;r<B.length;r++){o=B[r];try{o(S)}catch(n){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:l,dependencyId:S[r],error:n}),t.ignoreErrored||U||(U=n)}}}for(r=0;r<M.length;r++){var D=M[r];l=D.module,C=[l];try{f(l)}catch(n){if("function"==typeof D.errorHandler)try{D.errorHandler(n)}catch(e){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:l,error:e,orginalError:n}),t.ignoreErrored||U||(U=e),U||(U=n)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:l,error:n}),t.ignoreErrored||U||(U=n)}}return U?(s("fail"),Promise.reject(U)):(s("idle"),new Promise(function(n){n(h)}))}function f(e){if(N[e])return N[e].exports;var t=N[e]={i:e,l:!1,exports:{},hot:r(e),parents:(O=C,C=[],O),children:[]};return n[e].call(t.exports,t,t.exports,o(e)),t.l=!0,t.exports}var d=this.webpackHotUpdate;this.webpackHotUpdate=function(n,e){u(n,e),d&&d(n,e)};var m,p,y,g,_=!0,x="c9c283ea31d4cc59f186",b={},C=[],O=[],k=[],I="idle",P=0,L=0,M={},w={},A={},N={};f.m=n,f.c=N,f.i=function(n){return n},f.d=function(n,e,t){f.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:t})},f.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return f.d(e,"a",e),e},f.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},f.p="",f.h=function(){return x},o(8)(f.s=8)}([function(n,e,t){"use strict";function i(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function n(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}return function(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),e}}(),r=Math.sqrt(2),s=function(){function n(e,t){i(this,n),this.re=e,this.im=t}return o(n,[{key:"add",value:function(e){return new n(this.re+e.re,this.im+e.im)}},{key:"sub",value:function(e){return new n(this.re-e.re,this.im-e.im)}},{key:"mult",value:function(e){return new n(this.re*e.re-this.im*e.im,this.re*e.im+this.im*e.re)}},{key:"div",value:function(e){if(e.isInfinity())return n.ZERO;var t=e.re*e.re+e.im*e.im;return t<1e-7?new n(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY):new n((this.re*e.re+this.im*e.im)/t,(this.im*e.re-this.re*e.im)/t)}},{key:"scale",value:function(e){return new n(this.re*e,this.im*e)}},{key:"arg",value:function(){return Math.atan2(this.im,this.re)}},{key:"conjugate",value:function(){return new n(this.re,-this.im)}},{key:"normalize",value:function(){return this.scale(1/this.abs())}},{key:"abs",value:function(){return Math.sqrt(this.re*this.re+this.im*this.im)}},{key:"absSq",value:function(){return this.re*this.re+this.im*this.im}},{key:"eq",value:function(n){var e=this.re-n.re,t=this.im-n.im;return e*e+t*t<1e-7}},{key:"sq",value:function(){return new n(this.re*this.re-this.im*this.im,this.re*this.im+this.im*this.re)}},{key:"sqrt",value:function(){return this.im>0?new n(Math.sqrt(this.re+Math.sqrt(this.re*this.re+this.im*this.im))/r,Math.sqrt(-this.re+Math.sqrt(this.re*this.re+this.im*this.im))/r):this.i<0?new n(Math.sqrt(this.re+Math.sqrt(this.re*this.re+this.im*this.im))/r,-Math.sqrt(-this.re+Math.sqrt(this.re*this.re+this.im*this.im))/r):this.re<0?new n(0,Math.sqrt(Math.abs(this.re))):new n(Math.sqrt(this.re),0)}},{key:"isInfinity",value:function(){return this.re===Number.POSITIVE_INFINITY||this.im===Number.POSITIVE_INFINITY}},{key:"isZero",value:function(){return Math.abs(this.re)<1e-7&&Math.abs(this.im)<1e-7}},{key:"isReal",value:function(){return Math.abs(this.im)<1e-7}},{key:"isPureImaginary",value:function(){return Math.abs(this.re)<1e-7}},{key:"hasNaN",value:function(){return isNaN(this.re)||isNaN(this.im)}},{key:"linearArray",get:function(){return[this.re,this.im]}}],[{key:"sum",value:function(n,e){return n.add(e)}},{key:"diff",value:function(n,e){return n.sub(e)}},{key:"prod",value:function(n,e){return n.mult(e)}},{key:"quot",value:function(n,e){return n.div(e)}},{key:"conjugate",value:function(n){return n.conjugate()}},{key:"abs",value:function(n){return n.abs()}},{key:"absSq",value:function(n){return n.absSq()}},{key:"eq",value:function(n,e){var t=n.re-e.re,i=n.im-e.im;return t*t+i*i<1e-7}},{key:"distance",value:function(n,e){return n.sub(e).abs()}},{key:"sq",value:function(n){return n.sq()}},{key:"sqrt",value:function(n){return n.sqrt()}},{key:"dot",value:function(n,e){return n.re*e.re+n.im*e.im}},{key:"ZERO",get:function(){return new n(0,0)}},{key:"ONE",get:function(){return new n(1,0)}},{key:"I",get:function(){return new n(0,1)}},{key:"MINUS_ONE",get:function(){return new n(-1,0)}},{key:"INFINITY",get:function(){return new n(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}}]),n}();e.default=s},function(n,e,t){"use strict";function i(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function o(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}function r(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0}),e.Maskit3dCanvas=e.InvertedMaskitCanvas=e.MaskitCanvas=void 0;var s=function(){function n(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}return function(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),e}}(),a=t(7),c=t(0),u=function(n){return n&&n.__esModule?n:{default:n}}(c),l=t(9),v=function(){function n(e,t,i){r(this,n),this.canvasId=e,this.maskit=t,this.fragment=i,this.canvas=document.getElementById(e),this.pixelRatio=window.devicePixelRatio,this.canvas.style.width=this.canvas.width+"px",this.canvas.style.height=this.canvas.height+"px",this.canvas.width=this.canvas.width*this.pixelRatio,this.canvas.height=this.canvas.height*this.pixelRatio,this.canvasRatio=this.canvas.width/this.canvas.height/2,this.gl=(0,a.GetWebGL2Context)(this.canvas),this.setupShader(),this.setUniformLocations(),this.translate=new u.default(0,1),this.scale=2.1,this.kleinIterations=200,this.sceneScaleFactor=1.5}return s(n,[{key:"hideCanvas",value:function(){this.canvas.style.display="none"}},{key:"showCanvas",value:function(){this.canvas.style.display="inline"}},{key:"toggleCanvas",value:function(){"none"===this.canvas.style.display?(this.showCanvas(),this.render()):this.hideCanvas()}},{key:"setupShader",value:function(){this.vertexBuffer=(0,a.CreateSquareVbo)(this.gl),this.renderProgram=this.gl.createProgram(),(0,a.AttachShader)(this.gl,l,this.renderProgram,this.gl.VERTEX_SHADER),(0,a.AttachShader)(this.gl,this.fragment,this.renderProgram,this.gl.FRAGMENT_SHADER),(0,a.LinkProgram)(this.gl,this.renderProgram),this.renderVAttrib=this.gl.getAttribLocation(this.renderProgram,"a_vertex"),this.gl.enableVertexAttribArray(this.renderVAttrib)}},{key:"setUniformLocations",value:function(){this.uniLocations=[],this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_resolution")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_geometry")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_kleinIterations")),this.maskit.setUniformLocations(this.gl,this.uniLocations,this.renderProgram)}},{key:"setUniformValues",value:function(){var n=0;this.gl.uniform2f(this.uniLocations[n++],this.canvas.width,this.canvas.height),this.gl.uniform3f(this.uniLocations[n++],this.translate.re,this.translate.im,this.scale),this.gl.uniform1i(this.uniLocations[n++],this.kleinIterations),n=this.maskit.setUniformValues(this.gl,this.uniLocations,n,this.scale)}},{key:"render",value:function(){"none"!==this.canvas.style.display&&(this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.useProgram(this.renderProgram),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexBuffer),this.gl.vertexAttribPointer(this.renderCanvasVAttrib,2,this.gl.FLOAT,!1,0,0),this.setUniformValues(),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.flush())}},{key:"calcCanvasCoord",value:function(n,e){var t=this.canvas.getBoundingClientRect();return new u.default(this.scale*((n-t.left)*this.pixelRatio/this.canvas.height-this.canvasRatio),this.scale*-((e-t.top)*this.pixelRatio/this.canvas.height-.5))}},{key:"calcSceneCoord",value:function(n,e){return this.calcCanvasCoord(n,e).add(this.translate)}},{key:"setupMouseListener",value:function(){this.mouseState={isPressing:!1,prevPosition:new u.default(0,0),prevTranslate:new u.default(0,0),button:-1},this.boundOnMouseWheel=this.onMouseWheel.bind(this),this.canvas.addEventListener("wheel",this.boundOnMouseWheel),this.boundOnMouseDown=this.onMouseDown.bind(this),this.canvas.addEventListener("mousedown",this.boundOnMouseDown),this.boundOnMouseMove=this.onMouseMove.bind(this),this.canvas.addEventListener("mousemove",this.boundOnMouseMove),this.boundOnMouseUp=this.onMouseUp.bind(this),this.canvas.addEventListener("mouseup",this.boundOnMouseUp),this.canvas.addEventListener("contextmenu",function(n){return n.preventDefault()})}},{key:"onMouseWheel",value:function(n){n.preventDefault(),n.deltaY>0?this.scale*=this.sceneScaleFactor:this.scale/=this.sceneScaleFactor,this.render()}},{key:"onMouseDown",value:function(n){}},{key:"onMouseMove",value:function(n){}},{key:"onMouseUp",value:function(n){this.mouseState.isPressing=!1,this.maskit.release()}}],[{key:"MOUSE_BUTTON_LEFT",get:function(){return 0}},{key:"MOUSE_BUTTON_WHEEL",get:function(){return 1}},{key:"MOUSE_BUTTON_RIGHT",get:function(){return 2}}]),n}();e.MaskitCanvas=function(n){function e(n,t,o){r(this,e);var s=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n,t,o));return s.maskit.addParameterChangedListener(function(n){s.render()}),s.setupMouseListener(),s}return o(e,n),s(e,[{key:"onMouseDown",value:function(n){n.preventDefault();var e=this.calcSceneCoord(n.clientX,n.clientY);n.button===v.MOUSE_BUTTON_LEFT&&(this.maskit.select(e),this.render()),this.mouseState.prevPosition=e,this.mouseState.prevTranslate=this.translate,this.mouseState.isPressing=!0,this.mouseState.button=n.button}},{key:"onMouseMove",value:function(n){var e=this.calcSceneCoord(n.clientX,n.clientY);this.maskit.updateOrbitPoints(e),this.mouseState.isPressing&&(this.mouseState.button===v.MOUSE_BUTTON_LEFT?this.maskit.move(e):this.mouseState.button===v.MOUSE_BUTTON_RIGHT&&(this.translate=this.translate.sub(e.sub(this.mouseState.prevPosition)),this.render()))}}]),e}(v),e.InvertedMaskitCanvas=function(n){function e(n,t,o){r(this,e);var s=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n,t,o));return s.maskit.addParameterChangedListener(function(n){s.render()}),s.setupMouseListener(),s}return o(e,n),s(e,[{key:"onMouseDown",value:function(n){n.preventDefault();var e=this.calcSceneCoord(n.clientX,n.clientY);this.mouseState.prevPosition=e,this.mouseState.prevTranslate=this.translate,this.mouseState.isPressing=!0,this.mouseState.button=n.button}},{key:"onMouseMove",value:function(n){if(this.mouseState.isPressing){var e=this.calcSceneCoord(n.clientX,n.clientY);this.mouseState.button===v.MOUSE_BUTTON_RIGHT&&(this.translate=this.translate.sub(e.sub(this.mouseState.prevPosition)),this.render())}}}]),e}(v),e.Maskit3dCanvas=function(n){function e(n,t,o){r(this,e);var s=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n,t,o));return s.cameraPos=[0,1,1],s.cameraUp=[0,1,0],s.cameraTarget=[0,1,0],s.cameraDistance=2,s.cameraLnglat=[90,0],s.mouseDownLngLat=[0,0],s.setupMouseListener(),s.updateCamera(),s.maskit.addParameterChangedListener(function(n){s.render()}),s}return o(e,n),s(e,[{key:"updateCamera",value:function(){var n=(90-this.cameraLnglat[1])*Math.PI/180,e=this.cameraLnglat[0]*Math.PI/180;this.cameraPos=[this.cameraDistance*Math.sin(n)*Math.cos(e),Math.max(-.9,this.cameraDistance*Math.cos(n)),this.cameraDistance*Math.sin(n)*Math.sin(e)],this.cameraPos=[this.cameraPos[0]+this.cameraTarget[0],this.cameraPos[1]+this.cameraTarget[1],this.cameraPos[2]+this.cameraTarget[2]],this.render()}},{key:"onMouseDown",value:function(n){n.preventDefault();var e=this.calcCanvasCoord(n.clientX,n.clientY);this.mouseState.prevPosition=e,this.mouseState.prevTranslate=this.translate,this.mouseDownLngLat=this.cameraLnglat,this.mouseState.isPressing=!0}},{key:"onMouseMove",value:function(n){if(n.preventDefault(),this.mouseState.isPressing){var e=this.calcCanvasCoord(n.clientX,n.clientY);this.cameraLnglat=[50.5*(this.mouseState.prevPosition.re-e.re)+this.mouseDownLngLat[0],50.5*(e.im-this.mouseState.prevPosition.im)+this.mouseDownLngLat[1]],this.updateCamera()}}},{key:"onMouseWheel",value:function(n){n.preventDefault(),n.deltaY>0?this.cameraDistance*=1.25:this.cameraDistance&&(this.cameraDistance/=1.25),this.updateCamera()}},{key:"setUniformLocations",value:function(){this.uniLocations=[],this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_resolution")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_cameraPos")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_cameraTarget")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_cameraUp")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_kleinIterations")),this.maskit.setUniformLocations(this.gl,this.uniLocations,this.renderProgram)}},{key:"setUniformValues",value:function(){var n=0;this.gl.uniform2f(this.uniLocations[n++],this.canvas.width,this.canvas.height),this.gl.uniform3f(this.uniLocations[n++],this.cameraPos[0],this.cameraPos[1],this.cameraPos[2]),this.gl.uniform3f(this.uniLocations[n++],this.cameraTarget[0],this.cameraTarget[1],this.cameraTarget[2]),this.gl.uniform3f(this.uniLocations[n++],this.cameraUp[0],this.cameraUp[1],this.cameraUp[2]),this.gl.uniform1i(this.uniLocations[n++],this.kleinIterations),n=this.maskit.setUniformValues(this.gl,this.uniLocations,n,this.scale)}}]),e}(v)},function(n,e,t){"use strict";function i(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function n(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}return function(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),e}}(),r=t(0),s=function(n){return n&&n.__esModule?n:{default:n}}(r),a=function(){function n(e,t,o){i(this,n),this.t=new s.default(e,t),this.n=o,this.k=2*Math.cos(Math.PI/this.n),this.update(),this.pointRadius=.03,this.lineWidth=.01,this.circumferenceWidth=.02,this.selectedComponentId=-1,this.diffToComponent=new s.default(0,0),this.invCircleCenter=new s.default(0,1),this.invCircleR=1,this.drawLines=!1,this.drawCircle=!1,this.applyInversion=!0,this.trackOrbit=!1,this.drawInner=!1,this.parameterChangedListener=[],this.maxOrbitPoints=20,this.orbitPoints=new Array(2*this.maxOrbitPoints)}return o(n,[{key:"addParameterChangedListener",value:function(n){this.parameterChangedListener.push(n)}},{key:"onParameterChanged",value:function(){var n=!0,e=!1,t=void 0;try{for(var i,o=this.parameterChangedListener[Symbol.iterator]();!(n=(i=o.next()).done);n=!0){(0,i.value)(this)}}catch(n){e=!0,t=n}finally{try{!n&&o.return&&o.return()}finally{if(e)throw t}}}},{key:"release",value:function(){this.selectedComponentId=-1}},{key:"update",value:function(){this.symmetricalPoint=new s.default(.5*-this.t.im,.5*this.t.re),this.halfK=.5*this.k,this.rightBelowP=new s.default(this.halfK,0),this.leftBelowP=new s.default(-this.halfK,0),this.rightAbobeP=new s.default(this.halfK-this.t.im,this.t.re),this.leftAbobeP=new s.default(-this.halfK-this.t.im,this.t.re);var n=this.rightAbobeP.sub(this.rightBelowP);this.lineRightNormal=new s.default(-n.im,n.re),this.lineLeftNormal=this.lineRightNormal.scale(-1)}},{key:"updateOrbitPoints",value:function(n){this.trackOrbit&&(this.orbitPoints=this.computeOrbit(n,this.maxOrbitPoints),this.onParameterChanged())}},{key:"select",value:function(e){var t=e.sub(this.rightAbobeP);if(t.abs()<this.pointRadius)return this.selectedComponentId=n.POINT_RIGHT_ABOVE,this.diffToComponent=t,!0;var i=e.sub(this.rightBelowP);if(i.abs()<this.pointRadius)return this.selectedComponentId=n.POINT_RIGHT_BELOW,this.diffToComponent=i,!0;var o=e.sub(this.leftAbobeP);if(o.abs()<this.pointRadius)return this.selectedComponentId=n.POINT_LEFT_ABOVE,this.diffToComponent=o,!0;var r=e.sub(this.leftBelowP);if(r.abs()<this.pointRadius)return this.selectedComponentId=n.POINT_LEFT_BELOW,this.diffToComponent=r,!0;var a=e.sub(this.symmetricalPoint);if(a.abs()<this.pointRadius)return this.selectedComponentId=n.POINT_SYMMETRICAL,this.diffToComponent=a,!0;if(!this.drawCircle)return!1;var c=e.sub(this.invCircleCenter),u=c.abs(),l=this.invCircleR-u;return 0<l&&l<this.circumferenceWidth?(this.selectedComponentId=n.INVERSION_CIRCLE_CIRCUMFERENCE,this.diffToComponent=new s.default(l,l),!0):u<this.invCircleR&&(this.selectedComponentId=n.INVERSION_CIRCLE_BODY,this.diffToComponent=c,!0)}},{key:"move",value:function(e){switch(this.selectedComponentId){case n.POINT_RIGHT_ABOVE:var t=e.sub(this.diffToComponent);this.t=new s.default(t.im,this.halfK-t.re);break;case n.POINT_RIGHT_BELOW:var i=e.sub(this.diffToComponent);this.k=2*i.re;break;case n.POINT_LEFT_ABOVE:var o=e.sub(this.diffToComponent);this.t=new s.default(o.im,-this.halfK-o.re);break;case n.POINT_LEFT_BELOW:var r=e.sub(this.diffToComponent);this.k=2*r.re;break;case n.POINT_SYMMETRICAL:var a=e.sub(this.diffToComponent);this.t=new s.default(2*a.im,2*-a.re);break;case n.INVERSION_CIRCLE_BODY:this.invCircleCenter=e.sub(this.diffToComponent);break;case n.INVERSION_CIRCLE_CIRCUMFERENCE:this.invCircleR=s.default.distance(this.invCircleCenter,e)+this.diffToComponent.re;break;default:return!1}return this.update(),this.onParameterChanged(),!0}},{key:"lineY",value:function(n,e){return.5*e.re+Math.sign(.5*e.im)*(2*e.re-1.95)/4*Math.sign(n.re+.5*e.im)*(1-Math.exp(-(7.2-15*(1.95-e.re))*Math.abs(n.re+.5*e.im)))}},{key:"transA",value:function(n,e){var t=1/n.absSq(),i=n.scale(-t);return i.re=-e.im-i.re,i.im=e.re+i.im,i}},{key:"computeOrbit",value:function(n,e){for(var t=[n],i=1,o=new s.default(n.re,n.im),r=0;r<100;r++){var a=this.k/2+this.t.im*o.im/this.t.re;if((o.re<-a||a<o.re)&&(o.re+=a,o.re=o.re-this.k*Math.floor(o.re/this.k),o.re-=a,t.push(new s.default(o.re,o.im)),++i===e))break;if(o.im>=this.lineY(o,this.t)&&(o=new s.default(-this.t.im,this.t.re).sub(o),t.push(new s.default(o.re,o.im)),++i===e))break;if(o=this.transA(o,this.t),t.push(new s.default(o.re,o.im)),++i===e)break;if(o.im<0||this.t.re<o.im){for(var c=t[i-1],u=i;u<e;u++)t.push(c);break}}for(var l=new Array(2*e),v=0;v<e;v++)l[2*v+0]=t[v].re,l[2*v+1]=t[v].im;return l}},{key:"setUniformLocations",value:function(n,e,t){e.push(n.getUniformLocation(t,"u_maskit.uv")),e.push(n.getUniformLocation(t,"u_maskit.k")),e.push(n.getUniformLocation(t,"u_maskit.symmetricalPoint")),e.push(n.getUniformLocation(t,"u_maskit.lineLeftNormal")),e.push(n.getUniformLocation(t,"u_maskit.lineLeftPoints")),e.push(n.getUniformLocation(t,"u_maskit.lineRightNormal")),e.push(n.getUniformLocation(t,"u_maskit.lineRightPoints")),e.push(n.getUniformLocation(t,"u_maskit.inversionCircle")),e.push(n.getUniformLocation(t,"u_maskit.ui")),e.push(n.getUniformLocation(t,"u_maskit.drawLines")),e.push(n.getUniformLocation(t,"u_maskit.drawCircle")),e.push(n.getUniformLocation(t,"u_maskit.drawInner")),e.push(n.getUniformLocation(t,"u_maskit.applyInversion")),e.push(n.getUniformLocation(t,"u_maskit.trackOrbit")),e.push(n.getUniformLocation(t,"u_maskit.orbitPoints"))}},{key:"setUniformValues",value:function(n,e,t,i){var o=t;return n.uniform2f(e[o++],this.t.re,this.t.im),n.uniform1f(e[o++],this.k),n.uniform2f(e[o++],this.symmetricalPoint.re,this.symmetricalPoint.im),n.uniform2f(e[o++],this.lineLeftNormal.re,this.lineLeftNormal.im),n.uniform4f(e[o++],this.leftBelowP.re,this.leftBelowP.im,this.leftAbobeP.re,this.leftAbobeP.im),n.uniform2f(e[o++],this.lineRightNormal.re,this.lineRightNormal.im),n.uniform4f(e[o++],this.rightBelowP.re,this.rightBelowP.im,this.rightAbobeP.re,this.rightAbobeP.im),n.uniform4f(e[o++],this.invCircleCenter.re,this.invCircleCenter.im,this.invCircleR,this.invCircleR*this.invCircleR),n.uniform3f(e[o++],this.pointRadius,this.lineWidth,this.circumferenceWidth),n.uniform1i(e[o++],this.drawLines),n.uniform1i(e[o++],this.drawCircle),n.uniform1i(e[o++],this.drawInner),n.uniform1i(e[o++],this.applyInversion),n.uniform1i(e[o++],this.trackOrbit),n.uniform2fv(e[o++],this.orbitPoints),o}}],[{key:"POINT_RIGHT_ABOVE",get:function(){return 0}},{key:"POINT_RIGHT_BELOW",get:function(){return 1}},{key:"POINT_LEFT_ABOVE",get:function(){return 2}},{key:"POINT_LEFT_BELOW",get:function(){return 3}},{key:"POINT_SYMMETRICAL",get:function(){return 4}},{key:"INVERSION_CIRCLE_BODY",get:function(){return 5}},{key:"INVERSION_CIRCLE_CIRCUMFERENCE",get:function(){return 6}}]),n}();e.default=a},function(n,e){n.exports="#version 300 es\nprecision mediump float;\n\nconst int MAX_ORBIT_POINTS = 20;\nstruct Maskit {\n    vec2 uv;\n    float k;\n    vec2 symmetricalPoint;\n    vec2 lineLeftNormal;\n    vec4 lineLeftPoints; // [below, above]\n    vec2 lineRightNormal;\n    vec4 lineRightPoints;\n    vec4 inversionCircle;\n    vec3 ui; // [point radius, line width, circumference width]\n    bool drawLines;\n    bool drawCircle;\n    bool drawInner;\n    bool applyInversion;\n    bool trackOrbit;\n    vec2 orbitPoints[MAX_ORBIT_POINTS];\n};\n\n\nuniform vec2 u_resolution;\nuniform vec3 u_geometry; // [translateX, translateY, scale]\nuniform int u_kleinIterations;\nuniform Maskit u_maskit;\n\nconst vec3 BLACK = vec3(0, 0, 0.01);\nconst vec3 WHITE = vec3(1);\nconst vec3 RED = vec3(0.8, 0, 0);\nconst vec3 GREEN = vec3(0, 0.8, 0);\nconst vec3 BLUE = vec3(0, 0, 0.8);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 circleInvert(const vec2 pos, const vec4 circle){\n    vec2 p = pos - circle.xy;\n    float d = length(p);\n    return (p * circle.w)/(d * d) + circle.xy;\n}\n\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec2 TransA(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x; z.y = uv.x + z.y;\n    return z;\n}\n\nvec2 TransAInv(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z + vec2(uv.y,-uv.x), z + vec2(uv.y, -uv.x));\n\tz.x += uv.y; z.y = uv.x - z.y;\n\tz *= iR;\n    return z;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 computeColor(float n){\n\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n}\n\nvec3 computeColor2(float n, float numTransA) {\n    if(n == 0.) {\n        return u_maskit.drawInner ? computeColor(numTransA) : BLACK;\n    }\n    return hsv2rgb(vec3(0. + 0.05 * (n -1.), 1.0, 1.0));\n}\n\nconst int LOOP_NUM = 200;\nvec3 josKleinian(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        loopNum++;\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6)\n            return u_maskit.drawInner ?\n                hsv2rgb(vec3(0.01 * (loopNum-1.), 1., 1.)) :\n                BLACK;\n\n        if(pos.y <= 0. || uv.x < pos.y) {\n        \treturn computeColor(loopNum);\n        }\n\n        llz=lz; lz=pos;\n    }\n    return BLACK;\n}\n\nvec3 josKleinianIIS(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        numTransA++;\n        if(uv.x < pos.y) {\n            pos.y -= uv.x;\n            pos.y *= -1.;\n            pos.y += uv.x;\n            loopNum++;\n        }\n        if(pos.y <= 0.){\n            pos.y *= -1.;\n            loopNum++;\n        }\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) return computeColor2(loopNum, numTransA);\n\n        llz=lz; lz=pos;\n    }\n    return computeColor2(loopNum, numTransA);\n}\n\nbool renderUI(vec2 pos, out vec3 col){\n    col = BLACK;\n\n    if (distance(pos, u_maskit.symmetricalPoint) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    }\n\n    if(u_maskit.drawLines) {\n        // draw line3\n        if(abs(pos.y - lineY(pos, u_maskit.uv)) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw left line\n        float ldot = dot(u_maskit.lineLeftPoints.xy - pos, u_maskit.lineLeftNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw right line\n        ldot = dot(u_maskit.lineRightPoints.xy - pos, u_maskit.lineRightNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n    }\n    return false;\n}\n\n// front to back blend\nvec4 blendCol(vec4 srcC, vec4 outC){\n\tsrcC.rgb *= srcC.a;\n\treturn outC + srcC * (1.0 - outC.a);\n}\n\nfloat SAMPLE_NUM = 10.;\nout vec4 outColor;\nvoid main() {\n    vec3 sum = vec3(0);\n\tfloat ratio = u_resolution.x / u_resolution.y / 2.0;\n\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (gl_FragCoord.xy + (rand2n(gl_FragCoord.xy, i))) / u_resolution.yy ) - vec2(ratio, 0.5);\n        position *= u_geometry.z;\n        position += u_geometry.xy;\n\n        vec4 cc = vec4(0);\n        if(u_maskit.drawCircle) {\n            if(distance(position, u_maskit.inversionCircle.xy) < u_maskit.inversionCircle.z) {\n                cc = vec4(0, 0, 1., 0.5);\n            }\n        }\n\n        position = circleInvert(position, u_maskit.inversionCircle);\n        if(u_maskit.drawLines) {\n            vec3 c = BLACK;\n            bool render = renderUI(position, c);\n            if(render) {\n                sum += c;\n                continue;\n            }\n        }\n\n        if(u_maskit.applyInversion) {\n            sum += blendCol(vec4(josKleinianIIS(position,\n                                                u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        } else {\n            sum += blendCol(vec4(josKleinian(position,\n                                             u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        }\n    }\n    outColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n"},function(n,e){n.exports="#version 300 es\nprecision mediump float;\n\nconst int MAX_ORBIT_POINTS = 20;\nstruct Maskit {\n    vec2 uv;\n    float k;\n    vec2 symmetricalPoint;\n    vec2 lineLeftNormal;\n    vec4 lineLeftPoints; // [below, above]\n    vec2 lineRightNormal;\n    vec4 lineRightPoints;\n    vec4 inversionCircle;\n    vec3 ui; // [point radius, line width, circumference width]\n    bool drawLines;\n    bool drawCircle;\n    bool drawInner;\n    bool applyInversion;\n    bool trackOrbit;\n    vec2 orbitPoints[MAX_ORBIT_POINTS];\n};\n\nuniform vec2 u_resolution;\nuniform vec3 u_geometry; // [translateX, translateY, scale]\nuniform vec3 u_cameraPos;\nuniform vec3 u_cameraTarget;\nuniform vec3 u_cameraUp;\nuniform int u_kleinIterations;\nuniform Maskit u_maskit;\n\nconst vec3 BLACK = vec3(0, 0, 0.0);\nconst vec3 WHITE = vec3(1);\nconst vec3 RED = vec3(0.8, 0, 0);\nconst vec3 GREEN = vec3(0, 0.8, 0);\nconst vec3 BLUE = vec3(0, 0, 0.8);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst float OBJ_KLEIN = 0.;\nconst float OBJ_PLANE = 1.;\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1, out bool inBox) {\n\tfloat t0 = -1000000.0, t1 = 1000000.0;\n    hit0 = t0;\n    hit1 = t1;\n    inBox = false;\n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    \n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    \n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1 && 0. < t1) {\n        if(t0 < 0.) inBox = true;\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const vec2 resolution, const vec2 coord){\n    float imagePlane = (resolution.y * .5) / tan(fov * .5);\n    vec3 v = normalize(target - eye);\n    vec3 xaxis = normalize(cross(v, up));\n    vec3 yaxis =  normalize(cross(v, xaxis));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (xaxis * (resolution.x  *.5)) - (yaxis * (resolution.y * .5));\n    return normalize(origin + (xaxis * coord.x) + (yaxis * (resolution.y - coord.y)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec3 TransA(vec3 z, vec2 uv, inout float dr){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x;\n    z.y = uv.x + z.y;\n    dr *= iR;\n    return z;\n}\n\nvec3 sphereInvert(const vec3 pos, const vec4 sphere, inout float dr){\n\tvec3 diff = pos - sphere.xyz;\n    float dSq = dot(diff, diff);\n    float r2 = sphere.w * sphere.w;\n    dr *= r2 / dSq;\n\treturn (diff * r2) / (dSq) + sphere.xyz;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 distPlane(vec3 p, vec4 n) {\n    return vec4(OBJ_PLANE, dot(p, n.xyz) + n.w, 0, 0);\n}\n\nconst int LOOP_NUM = 20;\nvec4 JosKleinian(vec3 pos, const vec2 uv, const float translation) {\n    float loopNum = 0.;\n    vec3 lz = pos + vec3(1.);\n    vec3 llz = pos + vec3(-1.);\n    float numTransA = 0.;\n    float dr = 1.;\n    vec4 invSphere = vec4(u_maskit.inversionCircle.xy, 0,\n                          u_maskit.inversionCircle.z);\n    pos = sphereInvert(pos, invSphere, dr);\n\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos.xy, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec3(-uv.y, uv.x, 0) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv, dr);\n        loopNum++;\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) break;\n\n        llz=lz; lz=pos;\n    }\n\n    float y =  min(pos.y, uv.x - pos.y) ;\n    float d = 9999999.;\n\td = min(d, min(y, 0.3) / max(dr, 2.));\n    const float scalingFactor = 0.5;\n    return vec4(OBJ_KLEIN, d * scalingFactor, loopNum, numTransA);\n}\n\nvec4 opUnion(vec4 d1, vec4 d2) {\n    return d1.y < d2.y ? d1 : d2;\n}\n    \n\n// return [objId, distance, data, data]\nvec4 distFunc(const vec3 p){\n    vec4 d = distPlane(p, vec4(0, 1, 0, -0.001));\n    return (JosKleinian(p, u_maskit.uv, u_maskit.k));\n}\n\nconst vec2 NORMAL_COEFF = vec2(0.01, 0.);\nvec3 computeNormal(const vec3 p) {\n    return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy).y - distFunc(p - NORMAL_COEFF.xyy).y,\n                          distFunc(p + NORMAL_COEFF.yxy).y - distFunc(p - NORMAL_COEFF.yxy).y,\n                          distFunc(p + NORMAL_COEFF.yyx).y - distFunc(p - NORMAL_COEFF.yyx).y));\n}\n\nconst float EPSILON = 0.001;\nconst int MAX_MARCHING_LOOP = 500;\nvec4 march (const vec3 rayOrg, const vec3 rayDir,\n            const float t0, const float t1,\n            inout vec3 intersection, inout vec3 normal) {\n    vec3 rayPos = rayOrg + rayDir * t0;\n    vec4 dist = vec4(-1);\n    float rayLength = t0;\n    for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n        if(rayLength > t1) break;\n        dist = distFunc(rayPos);\n        rayLength += dist.y;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.y < EPSILON) {\n            intersection = rayPos;\n            normal = computeNormal(intersection);\n            dist.y = rayLength;\n            return dist; // [objId, distance from rayOrigin, data, data]\n        }\n    }\n    return vec4(-1);\n}\n\nfloat computeShadowFactor (const vec3 rayOrg, const vec3 rayDir,\n                           const float mint, const float maxt, const float k) {\n    float shadowFactor = 1.0;\n    for(float t = mint ; t < maxt ;){\n        float d = distFunc(rayOrg + rayDir * t).y;\n        if(d < EPSILON) {\n            shadowFactor = 0.;\n            break;\n        }\n\n        shadowFactor = min(shadowFactor, k * d / t);\n        t += d;\n    }\n    return clamp(shadowFactor, 0.0, 1.0);\n}\n\nvec3 computeColor(float n){\n    //\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n    return hsv2rgb(vec3(0. + 0.05 * (n -1.), 1.0, 1.0));\n}\n\nconst vec3 AMBIENT_FACTOR = vec3(0.1);\nconst vec3 LIGHT_DIR = normalize(vec3(1, .8, 1));\nvec3 calcColor(vec3 rayOrg, vec3 rayDir) {\n    float minDist = 9999999.;\n    vec3 intersection, normal;\n    vec3 color = vec3(0);\n\n    float hit0, hit1;\n    bool inBox;\n    bool hit = intersectBox(rayOrg, rayDir,\n                            vec3(-100), vec3( 100),\n                                hit0, hit1, inBox);\n    hit0 = (inBox) ? 0. : hit0;\n    \n    vec4 hitInfo = vec4(-1);\n    if(hit){    \n        hitInfo = march(rayOrg, rayDir, hit0, hit1,\n                        intersection, normal);\n    }\n    \n    if(hitInfo.x != -1.) {\n        vec3 matColor;\n        float k = 1.;\n        if(hitInfo.x == OBJ_KLEIN) {\n            matColor = computeColor(hitInfo.z);\n            //matColor = normal;\n            k = 1.;\n        }\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n        vec3 ambient = matColor * AMBIENT_FACTOR;\n        color = (diffuse * k + ambient);\n    }\n    //color = mix( vec3(0.6, 0.7, 1.0), color, exp( -0.01 * minDist * minDist) );\n    return color;\n}\n\nconst float SAMPLE_NUM = 1.;\nout vec4 outColor;\nvoid main() {\n    const float fov = radians(60.);\n    vec3 sum = vec3(0);\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n        vec3 ray = calcRay(u_cameraPos, u_cameraTarget, u_cameraUp, fov,\n                           u_resolution,\n                           gl_FragCoord.xy + coordOffset);\n\n        sum += calcColor(u_cameraPos, ray);\n    }\n    outColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n"},function(n,e){n.exports="#version 300 es\nprecision mediump float;\n\nconst int MAX_ORBIT_POINTS = 20;\nstruct Maskit {\n    vec2 uv;\n    float k;\n    vec2 symmetricalPoint;\n    vec2 lineLeftNormal;\n    vec4 lineLeftPoints; // [below, above]\n    vec2 lineRightNormal;\n    vec4 lineRightPoints;\n    vec4 inversionCircle;\n    vec3 ui; // [point radius, line width, circumference width]\n    bool drawLines;\n    bool drawCircle;\n    bool drawInner;\n    bool applyInversion;\n    bool trackOrbit;\n    vec2 orbitPoints[MAX_ORBIT_POINTS];\n};\n\nuniform vec2 u_resolution;\nuniform vec3 u_geometry; // [translateX, translateY, scale]\nuniform int u_kleinIterations;\nuniform Maskit u_maskit;\n\nconst vec3 BLACK = vec3(0, 0, 0.0);\nconst vec3 WHITE = vec3(1);\nconst vec3 RED = vec3(0.8, 0, 0);\nconst vec3 GREEN = vec3(0, 0.8, 0);\nconst vec3 BLUE = vec3(0, 0, 0.8);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 circleInvert(const vec2 pos, const vec4 circle){\n    vec2 p = pos - circle.xy;\n    float d = length(p);\n    return (p * circle.w)/(d * d) + circle.xy;\n}\n\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec2 TransA(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x; z.y = uv.x + z.y;\n    return z;\n}\n\nvec2 TransAInv(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z + vec2(uv.y,-uv.x), z + vec2(uv.y, -uv.x));\n\tz.x += uv.y; z.y = uv.x - z.y;\n\tz *= iR;\n    return z;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 computeColor(float n){\n\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n}\n\nvec3 computeColor2(float n, float numTransA) {\n    if(n == 0.) {\n        return u_maskit.drawInner ? computeColor(numTransA) : BLACK;\n    }\n    return hsv2rgb(vec3(0. + 0.05 * (n -1.), 1.0, 1.0));\n}\n\nconst int LOOP_NUM = 200;\nvec3 josKleinian(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        loopNum++;\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6)\n            return u_maskit.drawInner ?\n                hsv2rgb(vec3(0.01 * (loopNum-1.), 1., 1.)) :\n                BLACK;\n\n        if(pos.y <= 0. || uv.x < pos.y) {\n        \treturn computeColor(loopNum);\n        }\n\n        llz=lz; lz=pos;\n    }\n    return BLACK;\n}\n\nvec3 josKleinianIIS(vec2 pos, vec2 uv, float translation){\n    float loopNum = 0.;\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n\n    float numTransA = 0.;\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv);\n        numTransA++;\n        if(uv.x < pos.y) {\n            pos.y -= uv.x;\n            pos.y *= -1.;\n            pos.y += uv.x;\n            loopNum++;\n        }\n        if(pos.y <= 0.){\n            pos.y *= -1.;\n            loopNum++;\n        }\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) return computeColor2(loopNum, numTransA);\n\n        llz=lz; lz=pos;\n    }\n    return computeColor2(loopNum, numTransA);\n}\n\nbool renderUI(vec2 pos, out vec3 col){\n    col = BLACK;\n\n    if (distance(pos, u_maskit.symmetricalPoint) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineLeftPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.xy) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    } else if (distance(pos, u_maskit.lineRightPoints.zw) < u_maskit.ui.x) {\n        col = PINK;\n        return true;\n    }\n\n    if(u_maskit.drawLines) {\n        // draw line3\n        if(abs(pos.y - lineY(pos, u_maskit.uv)) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw left line\n        float ldot = dot(u_maskit.lineLeftPoints.xy - pos, u_maskit.lineLeftNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n\n        // draw right line\n        ldot = dot(u_maskit.lineRightPoints.xy - pos, u_maskit.lineRightNormal);\n        if(abs(ldot) < u_maskit.ui.y) {\n            col = WHITE;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 computeOrbitColor(float n) {\n    return u_maskit.applyInversion ?\n        hsv2rgb(vec3(.5 +0.03 * n, 1., 1.)):\n        hsv2rgb(vec3(0. + 0.03 * (n -1.), 1.0, 1.0));\n}\n\nbool renderOrbit(vec2 pos, out vec3 col){\n    col = vec3(0);\n    for(int i = 0; i < MAX_ORBIT_POINTS; i++) {\n        if(distance(pos, u_maskit.orbitPoints[i]) < u_maskit.ui.x * 1.2) {\n            col = computeOrbitColor(float(i));\n            return true;\n        }\n        if(i > 0) {\n            vec2 p1 = u_maskit.orbitPoints[i - 1];\n            vec2 p2 = u_maskit.orbitPoints[i];\n            vec2 v = p2 - p1;\n            vec2 n = normalize(vec2(-v.y, v.x));\n            vec2 posP1 = pos - p1;\n            vec2 posP2 = pos - p2;\n            if(dot(posP1, posP2) < 0. &&\n               abs(dot(n, posP1)) < u_maskit.ui.y) {\n                /*\n                float dist = distance(p1, p2);\n                float distP1Pos = length(posP1);\n                col = mix(computeOrbitColor(float(i)),\n                          computeOrbitColor(float(i-1)), distP1Pos / dist);\n                */\n                col = computeOrbitColor(float(i));\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// front to back blend\nvec4 blendCol(vec4 srcC, vec4 outC){\n\tsrcC.rgb *= srcC.a;\n\treturn outC + srcC * (1.0 - outC.a);\n}\n\nfloat SAMPLE_NUM = 10.;\nout vec4 outColor;\nvoid main() {\n    vec3 sum = vec3(0);\n\tfloat ratio = u_resolution.x / u_resolution.y / 2.0;\n\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (gl_FragCoord.xy + (rand2n(gl_FragCoord.xy, i))) / u_resolution.yy ) - vec2(ratio, 0.5);\n        position *= u_geometry.z;\n        position += u_geometry.xy;\n\n        vec3 c = BLACK;\n        bool render = renderUI(position, c);\n        if(render) {\n            sum += c;\n            continue;\n        }\n\n        vec4 cc = vec4(0);\n        if(u_maskit.drawCircle) {\n            float dist = distance(position, u_maskit.inversionCircle.xy);\n            float rdist = u_maskit.inversionCircle.z - dist;\n            if(0. < rdist && rdist < u_maskit.ui.z){\n                cc = vec4(0, 1, 0, 0.5);\n            } else if(dist < u_maskit.inversionCircle.z) {\n                cc = vec4(0, 0, 1, 0.5);\n            }\n        }\n\n        if(u_maskit.trackOrbit) {\n            bool render = renderOrbit(position, c);\n            if(render) {\n                sum += c;\n                continue;\n            }\n        }\n\n        if(u_maskit.applyInversion) {\n            sum += blendCol(vec4(josKleinianIIS(position,\n                                                u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        } else {\n            sum += blendCol(vec4(josKleinian(position,\n                                             u_maskit.uv, u_maskit.k), 1.), cc).rgb;\n        }\n    }\n    outColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n"},function(n,e){n.exports="#version 300 es\nprecision mediump float;\n\nconst int MAX_ORBIT_POINTS = 20;\nstruct Maskit {\n    vec2 uv;\n    float k;\n    vec2 symmetricalPoint;\n    vec2 lineLeftNormal;\n    vec4 lineLeftPoints; // [below, above]\n    vec2 lineRightNormal;\n    vec4 lineRightPoints;\n    vec4 inversionCircle;\n    vec3 ui; // [point radius, line width, circumference width]\n    bool drawLines;\n    bool drawCircle;\n    bool drawInner;\n    bool applyInversion;\n    bool trackOrbit;\n    vec2 orbitPoints[MAX_ORBIT_POINTS];\n};\n\nuniform vec2 u_resolution;\nuniform vec3 u_geometry; // [translateX, translateY, scale]\nuniform vec3 u_cameraPos;\nuniform vec3 u_cameraTarget;\nuniform vec3 u_cameraUp;\nuniform int u_kleinIterations;\nuniform Maskit u_maskit;\n\nconst vec3 BLACK = vec3(0, 0, 0.0);\nconst vec3 WHITE = vec3(1);\nconst vec3 RED = vec3(0.8, 0, 0);\nconst vec3 GREEN = vec3(0, 0.8, 0);\nconst vec3 BLUE = vec3(0, 0, 0.8);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst float OBJ_KLEIN = 0.;\nconst float OBJ_PLANE = 1.;\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1, out bool inBox) {\n\tfloat t0 = -1000000.0, t1 = 1000000.0;\n    hit0 = t0;\n    hit1 = t1;\n    inBox = false;\n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    \n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    \n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1 && 0. < t1) {\n        if(t0 < 0.) inBox = true;\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const vec2 resolution, const vec2 coord){\n    float imagePlane = (resolution.y * .5) / tan(fov * .5);\n    vec3 v = normalize(target - eye);\n    vec3 xaxis = normalize(cross(v, up));\n    vec3 yaxis =  normalize(cross(v, xaxis));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (xaxis * (resolution.x  *.5)) - (yaxis * (resolution.y * .5));\n    return normalize(origin + (xaxis * coord.x) + (yaxis * (resolution.y - coord.y)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec3 TransA(vec3 z, vec2 uv, inout float dr){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x;\n    z.y = uv.x + z.y;\n    dr *= iR;\n    return z;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 distPlane(vec3 p, vec4 n) {\n    return vec4(OBJ_PLANE, dot(p, n.xyz) + n.w, 0, 0);\n}\n\nconst int LOOP_NUM = 20;\nvec4 JosKleinian(vec3 pos, const vec2 uv, const float translation) {\n    float loopNum = 0.;\n    vec3 lz = pos + vec3(1.);\n    vec3 llz = pos + vec3(-1.);\n    float numTransA = 0.;\n    float dr = 1.;\n\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n\n        // rotate 180\n        if (pos.y >= lineY(pos.xy, uv.xy)){\n            // pos -= vec2(-uv.y, uv.x) * .5;\n            // pos = - pos;\n            // pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec3(-uv.y, uv.x, 0) - pos;\n            //loopNum++;\n        }\n\n        pos = TransA(pos, uv, dr);\n        loopNum++;\n\n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) break;\n\n        llz=lz; lz=pos;\n    }\n\n    float y =  min(pos.y, uv.x - pos.y) ;\n    float d = 9999999.;\n\td = min(d, min(y, 0.3) / max(dr, 2.));\n    const float scalingFactor = 0.5;\n    return vec4(OBJ_KLEIN, d * scalingFactor, loopNum, numTransA);\n}\n\nvec4 opUnion(vec4 d1, vec4 d2) {\n    return d1.y < d2.y ? d1 : d2;\n}\n    \n\n// return [objId, distance, data, data]\nvec4 distFunc(const vec3 p){\n    vec4 d = distPlane(p, vec4(0, 1, 0, -0.001));\n    return (JosKleinian(p, u_maskit.uv, u_maskit.k));\n}\n\nconst vec2 NORMAL_COEFF = vec2(0.01, 0.);\nvec3 computeNormal(const vec3 p) {\n    return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy).y - distFunc(p - NORMAL_COEFF.xyy).y,\n                          distFunc(p + NORMAL_COEFF.yxy).y - distFunc(p - NORMAL_COEFF.yxy).y,\n                          distFunc(p + NORMAL_COEFF.yyx).y - distFunc(p - NORMAL_COEFF.yyx).y));\n}\n\nconst float EPSILON = 0.001;\nconst int MAX_MARCHING_LOOP = 500;\nvec4 march (const vec3 rayOrg, const vec3 rayDir,\n            const float t0, const float t1,\n            inout vec3 intersection, inout vec3 normal) {\n    vec3 rayPos = rayOrg + rayDir * t0;\n    vec4 dist = vec4(-1);\n    float rayLength = t0;\n    for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n        if(rayLength > t1) break;\n        dist = distFunc(rayPos);\n        rayLength += dist.y;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.y < EPSILON) {\n            intersection = rayPos;\n            normal = computeNormal(intersection);\n            dist.y = rayLength;\n            return dist; // [objId, distance from rayOrigin, data, data]\n        }\n    }\n    return vec4(-1);\n}\n\nfloat computeShadowFactor (const vec3 rayOrg, const vec3 rayDir,\n                           const float mint, const float maxt, const float k) {\n    float shadowFactor = 1.0;\n    for(float t = mint ; t < maxt ;){\n        float d = distFunc(rayOrg + rayDir * t).y;\n        if(d < EPSILON) {\n            shadowFactor = 0.;\n            break;\n        }\n\n        shadowFactor = min(shadowFactor, k * d / t);\n        t += d;\n    }\n    return clamp(shadowFactor, 0.0, 1.0);\n}\n\nvec3 computeColor(float n){\n\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n}\n\nconst vec3 AMBIENT_FACTOR = vec3(0.1);\nconst vec3 LIGHT_DIR = normalize(vec3(1, .8, 1));\nvec3 calcColor(vec3 rayOrg, vec3 rayDir) {\n    float minDist = 9999999.;\n    vec3 intersection, normal;\n    vec3 color = vec3(0);\n\n    float hit0, hit1;\n    bool inBox;\n    bool hit = intersectBox(rayOrg, rayDir,\n                            vec3(-999, -999, -0.6), vec3(999., 999., 0.6),\n                            hit0, hit1, inBox);\n    hit0 = (inBox) ? 0. : hit0;\n\n    vec4 hitInfo = vec4(-1);\n    if(hit){    \n        hitInfo = march(rayOrg, rayDir, hit0, hit1,\n                        intersection, normal);\n    }\n    \n    if(hitInfo.x != -1.) {\n        vec3 matColor;\n        float k = 1.;\n        if(hitInfo.x == OBJ_KLEIN) {\n            matColor = computeColor(hitInfo.z);\n            //matColor = normal;\n            k = 1.;\n            k = computeShadowFactor(intersection + 0.01 * normal, LIGHT_DIR,\n                                    0.1, 1., 30.);\n        } else if(hitInfo.x == OBJ_PLANE) {\n            matColor = normal;//vec3(0.7);\n            k = computeShadowFactor(intersection + 0.01 * normal, LIGHT_DIR,\n                                    0.1, .5, 2.);\n        }\n\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n        vec3 ambient = matColor * AMBIENT_FACTOR;\n        color = (diffuse * k + ambient);\n    }\n    //color = mix( vec3(0.6, 0.7, 1.0), color, exp( -0.01 * minDist * minDist) );\n    return color;\n}\n\nconst float SAMPLE_NUM = 1.;\nout vec4 outColor;\nvoid main() {\n    const float fov = radians(60.);\n    vec3 sum = vec3(0);\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n        vec3 ray = calcRay(u_cameraPos, u_cameraTarget, u_cameraUp, fov,\n                           u_resolution,\n                           gl_FragCoord.xy + coordOffset);\n\n        sum += calcColor(u_cameraPos, ray);\n    }\n    outColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n"},function(n,e,t){"use strict";function i(n){new c;return n.getContext("webgl2")}function o(n,e){var t=n.createBuffer();return n.bindBuffer(n.ARRAY_BUFFER,t),n.bufferData(n.ARRAY_BUFFER,new Float32Array(e),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),t}function r(n){return o(n,u)}function s(n,e){new c;n.linkProgram(e),n.useProgram(e)}function a(n,e,t,i){var o=(new c,n.createShader(i));n.shaderSource(o,e),n.compileShader(o),n.attachShader(t,o)}Object.defineProperty(e,"__esModule",{value:!0});var c=function(){function n(){this.captured=[]}return n.prototype._capt=function(n,e){return this.captured.push({value:n,espath:e}),n},n.prototype._expr=function(n,e){var t=this.captured;return this.captured=[],{powerAssertContext:{value:n,events:t},source:e}},n}();e.GetWebGL2Context=i,e.CreateStaticVbo=o,e.CreateSquareVbo=r,e.LinkProgram=s,e.AttachShader=a;var u=[-1,-1,-1,1,1,-1,1,1]},function(n,e,t){"use strict";var i=t(2),o=function(n){return n&&n.__esModule?n:{default:n}}(i),r=t(1),s=t(5),a=t(3),c=t(6),u=t(4);window.addEventListener("load",function(){var n=new o.default(2,0,.5),e=new r.MaskitCanvas("canvas",n,s),t=new r.InvertedMaskitCanvas("invCanvas",n,a),i=new r.Maskit3dCanvas("3dCanvas",n,c),l=new r.Maskit3dCanvas("inv3dCanvas",n,u),v=document.getElementById("drawLineCheck");v.addEventListener("change",function(){n.drawLines=v.checked,e.render(),t.render()});var h=document.getElementById("drawCircleCheck");h.addEventListener("change",function(){n.drawCircle=h.checked,e.render(),t.render()});var f=document.getElementById("drawInnerCheck");f.addEventListener("change",function(){n.drawInner=f.checked,e.render(),t.render()});var d=document.getElementById("applyInversionCheck");d.addEventListener("change",function(){n.applyInversion=d.checked,e.render(),t.render()});var m=document.getElementById("trackOrbitCheck");m.addEventListener("change",function(){n.trackOrbit=m.checked,e.render(),t.render()}),document.getElementById("view3dCheck").addEventListener("change",function(){i.toggleCanvas(),t.toggleCanvas()}),e.render(),t.render(),i.render(),l.render()})},function(n,e){n.exports="#version 300 es\n\nin vec2 a_vertex;\nout vec2 v_texCoord;\n\nvoid main() {\n    v_texCoord = a_vertex.xy * 0.5 + 0.5;\n    gl_Position = vec4(a_vertex, 0., 1.0);\n}\n"}]);